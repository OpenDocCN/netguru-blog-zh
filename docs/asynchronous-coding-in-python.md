# Python 中的异步编码

> 原文：<http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/asynchronous-coding-in-python>

 异步编码并不是一个全新的概念——在过去几年中，它一直是一个大话题，但现在才被更广泛地使用。与传统的线性编程相反，在传统的线性编程中，事情遵循精确的顺序，每一步都必须在下一步开始之前完成，在异步流程中，没有一个步骤必须在前进之前完成。那么，它到底是怎么工作的呢？

## **单线程和多线程环境中的同步编程模型**

例如，如果您的脚本从多个不同的服务器请求数据，那么一步一步地执行指令可能会非常耗时。为什么？因为脚本在等待服务器响应时不能做任何事情，当然也不能继续下一个。 **那是一个运行在单线程中的同步程序。**

**在多线程环境** 中，你有许多线程，通常甚至更多的任务(比如请求)要处理，每个线程占用一个任务来完成。然后，无论哪个线程变得空闲和可用，都可以向下移动到下一个任务。

## **单线程和多线程环境下的异步编程模型**

一个异步程序不需要等待请求被执行，如果那会花费太多时间的话。 **在单线程中，** 它会跳过第一个请求，继续下一个请求，然后再回到它跳过的那个请求，从它停止的地方继续。

**拥有多个线程** ，一个异步程序不仅能够一次处理多个任务(称为 *并发* )，还可以通过不同的线程处理同一任务。例如，一个任务可以由一个线程启动，然后由另一个线程完成——一个恰好在此刻空闲的线程。这最大化了线程利用率。

还有一件事。说到多线程环境，更不用说**-**全局解释器锁定器** 。说到 [Python](/web/20220924162317/https://www.netguru.com/services/python-development) ，这与编程语言的两个实现有关——CPython 和 PyPy。GIL 是一个互斥体，防止多个线程同时处于执行状态。难怪它如此有争议，因为这个[成为了一个瓶颈，极大地影响了 Python](/web/20220924162317/https://www.netguru.com/blog/django-performance-optimization) 程序的性能。那么，为什么要用呢？因为 CPython 扩展需要 GIL 提供的线程安全内存管理。它会降低程序的性能，但另一方面，它也可以避免线程之间的复杂性。**

 **好的。所以，现在我们已经讨论了基础知识，让我们通过研究一些最重要的概念来看看异步编码是如何完成的。

## **异步 Python: 4 亮点**

## **1。Python 3.5+ asyncio -异步 I/O**

*[asyncio](http://web.archive.org/web/20220924162317/https://docs.python.org/3/library/asyncio.html)*是一个 Python 核心库，专门用来让异步代码更简单、可读性更好(几乎像同步代码一样)，没有任何 *[回调](http://web.archive.org/web/20220924162317/https://en.wikipedia.org/wiki/Callback_(computer_programming))* 。它使用 async/await 语法，包括如下结构:

*   **事件循环**——这管理着各种任务的执行。它是负责处理输入/输出(I/O)和系统事件的中央执行器；

*   **协程**——这些是特殊的函数，类似于 Python 生成器(只是它们不生成数据——它们消耗数据)，它们用于协同多任务处理。他们可以放弃对调用者的控制，以便能够同时运行多个应用程序；

*   **任务**——这些用于并发调度协程。

使用 asyncio，您可以编写单线程并发代码。它是如何工作的？简而言之，子任务被定义为协程，所以您可以随意调度它们。例如，您可以将它们与事件循环同时安排。在协程产出点中，您还可以定义一些发生上下文切换的点。只有当有挂起的任务时，才会发生这种情况。如果没有，那么就没有上下文切换。

CPython 的这个增强版支持 **微线程** (称为 *微线程* )的概念，允许开发者在基于线程的环境中编程，将复杂性和性能问题降到最低。

在无堆栈中，微线程在同一个 CPU 内核中处理各种子任务的完成，作为传统的基于事件的异步编码 的替代 **。借助通信通道、调度、任务序列化和协程支持等附加功能，程序员会发现效率显著提高，代码更加简洁，整个应用程序的结构得到了全面改善。**

**3。** **[格林利特](http://web.archive.org/web/20220924162317/https://greenlet.readthedocs.io/)**

这反过来又是一个原始的 **派生的微线程无栈** 。Greenlet 是作为 C 扩展模块提供给 Python 的。它没有隐式调度功能，当您想在代码运行 和 **时保持** **控制时，以及当您的**工作具有相对较小的 I/O 时，它会非常方便有效。

在 greenlet 之上，你可以构建 **微线程** 并随意调度。但是它也可以单独使用，以便创建高级控制流结构。然而，greenlet 使用 Web Workers，并且只支持浏览器环境。

**4。****[Gevent](http://web.archive.org/web/20220924162317/http://www.gevent.org/)**

Gevent 是一个基于协程的库，它使用 Greenlet 来提供一个高级同步 API**，一个重用来自 Python 标准库的事件和队列等概念的 API。它的特点是建立在[libev](http://web.archive.org/web/20220924162317/http://software.schmorp.de/pkg/libev.html)或[libuv](http://web.archive.org/web/20220924162317/http://libuv.org/)之上的快速事件循环、轻量级和基于 greenlet 的执行单元、线程池以及支持 SSL 的协作套接字。**

 **Gevent 在最大限度地减少与传统线程 相关的开销方面 **相当强大。它可以用于数据库、web 服务器和消息传递框架的并发实现。然而，它并不真正适合多核 CPU 程序。**

## **总结**

虽然异步编码对于 Python 程序员来说可能不像对于 JavaScript 开发人员来说那么微不足道，但是仍然有一些很好的理由对异步范式产生一点兴趣。

其中一个原因是 **app 性能** 。你当然不想浪费大部分时间等待任务完成。还有一个原因，与第一个紧密相连，就是 [**用户** **体验**](/web/20220924162317/https://www.netguru.com/blog/ux-tips-to-improve-website-navigation) 。应用程序运行得越快越流畅，用户留下来继续愉快地使用它的机会就越高。

因此，深入这个主题，看看异步编程是否是可以利用的。在某些情况下，这是完全没有必要的，但是要知道有些程序仅仅依赖于这种类型的编码。****