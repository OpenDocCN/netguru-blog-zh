<html>
<head>
<title>HTTP Debugging in iOS Made Easier with ResponseDetective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>iOS中的HTTP调试通过ResponseDetective变得更加容易</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/response-detective-ios-open-source#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/response-detective-ios-open-source#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h2"><p>我们很高兴宣布我们新的开源iOS工具HTTP de</p> 
<p>窃听-响应检测。</p></div><p>你在请求完成回调中放了多少次<code>NSLog</code>？你有多少次使用断点来检查发送给你的API服务的头和体？现在，那些都是过去的事了！我们很高兴宣布我们新的开源for HTTP调试工具—<a href="http://web.archive.org/web/20221007091626/https://github.com/netguru/ResponseDetective">response detective</a>。</p>
<p>网络层的夏洛克·福尔摩斯</p>
<h2>有时会出现问题——这很正常，<a href="/web/20221007091626/https://www.netguru.com/services/ios-mobile-app-development" rel="noopener">当同时开发iOS移动应用</a>和后端API时，这种情况经常发生。在这种情况下，快速检查网络层发生了什么非常重要——发送和接收了哪些报头，以及进出了哪些有效载荷。以前，您必须在API客户端实现内部手工注入断点和日志。这是可行的，但是它既不可维护，也不可扩展。输入ResponseDetective。您所要做的就是用几行代码设置所需的拦截器，并将一个<code>NSURLProtocol</code>注入到您的会话的<code>NSURLSessionConfiguration</code>中。</h2>
<p>好的基础</p>
<h2>ResponseDetective没有使用私有的API，只是在<code>NSURLProtocol</code>之上的一个花哨的层，这个类从iOS 2.0就存在了，被<a href="http://web.archive.org/web/20221007091626/https://github.com/kylef/Mockingjay">的许多</a> <a href="http://web.archive.org/web/20221007091626/https://github.com/AliSoftware/OHHTTPStubs">请求存根</a> <a href="http://web.archive.org/web/20221007091626/https://github.com/luisobo/Nocilla">库</a>使用。结果是，如果你使用的是<code>NSURLSession</code>，每次你执行一个HTTP请求时，它会要求每个注册的NSURLProtocol执行它，如果它们可以的话。</h2>
<p>ResponseDetective uses no private APIs and is just a fancy layer on top of <code>NSURLProtocol</code>, a class which has existed since iOS 2.0 and is used by <a href="http://web.archive.org/web/20221007091626/https://github.com/kylef/Mockingjay">many</a> <a href="http://web.archive.org/web/20221007091626/https://github.com/AliSoftware/OHHTTPStubs">request stubbing</a> <a href="http://web.archive.org/web/20221007091626/https://github.com/luisobo/Nocilla">libraries</a>. Turns out, if you’re using <code>NSURLSession</code>, every time you execute an HTTP request, it asks each registered NSURLProtocol to perform it if they’re able to.</p>
<p class="text-center"/><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020338-png/blog-files/1437396964-1437396962-image01.png 0w" src="../Images/aaddf13403e897c311e771c960aa5b9c.png" alt="" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020338-png/blog-files/1437396964-1437396962-image01.png"/>
  </figure><p> </p>
<p class="cc text-center">这就是反应检测的用武之地。它提供了<code>NSURLProtocol</code>的子类，该子类首先拦截请求，执行请求，最后拦截响应。说到截击机...</p>
<p>定制的新水平</p>
<h2>默认情况下，ResponseDetective不做任何事情。是你，用户，决定它如何工作，拦截什么。想要打印所有发出的JSON请求吗？没问题！</h2>
<p>想要将所有XML响应转储保存在一个数组中吗？给你！<span> </span></p>
<p>也许你想利用你那令人敬畏的<a href="http://web.archive.org/web/20221007091626/https://github.com/CocoaLumberjack/CocoaLumberjack"> CocoaLumberjack </a>装置？再简单不过了！只需实现自己的输出流类型，并将其作为<code>outputStream</code>参数传递。</p>
<p>你甚至可以创建自己的拦截器，倾倒任何你想要的东西。只要执行一个相关的协议，你就可以开始了。</p>
<p class="legacy-code-gist" data-gist-id="b96ef6d476e40742b3e7">技术挑战</p>
<h2>对于这么小的项目，所有的API都应该尽可能简单，我们不希望有任何障碍。正如你可能猜到的，事实并非如此。</h2>
<p>首先引起我们注意的是<code>NSURLProtocol</code>的接口，原来是，不是基于实例，而是基于类。对我来说，我认为<a href="http://web.archive.org/web/20221007091626/https://twitter.com/teozaurus/status/518071391959388160">共享易变状态是敌人</a>，这是一个巨大的失望。我们不得不根据类方法来重新思考我们的API。</p>
<p>一开始，我们决定我们的库将没有依赖项，并且将用纯Swift编写。一切都很顺利，直到我们不得不在libxml之上实现一个<a href="http://web.archive.org/web/20221007091626/http://stackoverflow.com/questions/19857045/pretty-print-xml-from-nsstring-in-objective-c"> XML修饰器</a>。</p>
<p>In the beginning, we decided that our library would have no dependencies and would be written in pure Swift. It was all going well until we had to implement an <a href="http://web.archive.org/web/20221007091626/http://stackoverflow.com/questions/19857045/pretty-print-xml-from-nsstring-in-objective-c">XML prettifier</a> on top of libxml.</p>
<p class="text-center"/><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020348-png/blog-files/1437396964-1437396962-image02.png 0w" src="../Images/4bfde65ed8afa9a8d071bd0cbfcc88b2.png" alt="" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020348-png/blog-files/1437396964-1437396962-image02.png"/>
  </figure><p> </p>
<p class="cc text-center">好了，让我们创建一个桥接标题，然后<code>#import &lt;libxml/tree.h&gt;</code>就这样！</p>
<p>Alright, let’s create a bridging header and <code>#import &lt;libxml/tree.h&gt;</code> there!</p>
<p class="text-center"/><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020358-png/blog-files/1437396964-1437396962-image00.png 0w" src="../Images/705a265100bf5bc0b8b5b5204ca89e21.png" alt="" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020358-png/blog-files/1437396964-1437396962-image00.png"/>
  </figure><p> </p>
<p class="cc text-center">就在这时，我们想起Swift模块不支持任何静态库连接。我们别无选择，只能在Objective-C中实现修饰器(违反了我们声明的目标),并使用桥接头将函数导出到Swift，顺便说一下，<a href="http://web.archive.org/web/20221007091626/http://stackoverflow.com/questions/24875745/xcode-6-beta-4-using-bridging-headers-with-framework-targets-is-unsupported">在框架目标</a>中应该是不可能的。</p>
<p>思考不同</p>
<h2>ResponseDetective不同于其他开源项目的另一点是它经过重新思考的设置。</h2>
<p>我们没有包含一个演示应用程序，它没有特定的用途，并且每次用户想玩这个框架时都需要重新编译，我们决定包含一个演示<a href="http://web.archive.org/web/20221007091626/https://developer.apple.com/library/ios/recipes/Playground_Help/Chapters/AboutPlaygrounds.html"> playground </a>。这开辟了一条包含丰富文档和真实代码示例的道路，这是向潜在用户介绍框架的最佳方式。</p>
<p>此外，ResponseDetective利用了预先构建的<a href="http://web.archive.org/web/20221007091626/https://github.com/Carthage/Carthage"> Carthage </a>依赖项。结果？由于Carthage不构建依赖项(不像CocoaPods)，我们设法实现了空前的记录——在我们的持续集成服务器上构建42秒。</p>
<p>这只是开始</p>
<p class="text-center">ResponseDetective是一个新项目，仍然有很多工作要做，因为我们不断提出新的想法和集思广益的改进。</p><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020368-png/blog-files/1437396965-1437396963-image03.png 0w" src="../Images/b3cc98b2065931dc2a42008c91717de5.png" alt="" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221007091626im_/https://www.netguru.com/hs-fs/hub/493098/file-3517020368-png/blog-files/1437396965-1437396963-image03.png"/>
  </figure><p>最后但同样重要的是，没有开放就没有开源——如果您有任何评论、问题或改进的想法，请随时提出问题并为项目贡献力量。</p>
<p class="cc text-center"><em>我们正在进行更多的<a href="http://web.archive.org/web/20221007091626/https://www.netguru.com/resources">开源项目</a>——请随意使用我们已有的资源，或者加入我们。我们也很想在推特上见到你-<a href="http://web.archive.org/web/20221007091626/https://twitter.com/netguru">@网络大师</a>。</em></p>
<h2>It’s Just The Beginning</h2>
<p>ResponseDetective is a fresh project and there’s still a lot of work to do as we’re constantly coming up with new ideas and brainstorming improvements.</p>
<p>Last but not least, there is no open source without openness – if you have any comments, questions or ideas for improvements, feel free to open an issue and <a href="http://web.archive.org/web/20221007091626/https://github.com/netguru/ResponseDetective">contribute to the project</a>.</p>
<p><em>There are more <a href="http://web.archive.org/web/20221007091626/https://www.netguru.com/resources">open source projects</a> we’re working on - help yourself to what we’ve got, or join us. We'd love to meet you on Twitter, too - <a href="http://web.archive.org/web/20221007091626/https://twitter.com/netguru">@netguru</a>.</em></p></span></div>    
</body>
</html>