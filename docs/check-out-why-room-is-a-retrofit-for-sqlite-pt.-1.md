# 了解为什么房间是 SQLite - pt 的改型。一

> 原文：<http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/check-out-why-room-is-a-retrofit-for-sqlite-pt.-1>

 谷歌 I/O 2017 相当具有革命性。我们已经看到了许多令人惊叹的新产品发布，并听说谷歌将在机器学习相关技术上投入大量资金。

今年的 I/O 对于 Android 开发者来说也是非同寻常的，因为我们终于获得了对 Kotlin 的官方支持(耶！)和一个全新的名为“Android 架构组件”的 Android 库集合。

现在是测试新解决方案的时候了。之前，我们研究了[新的生命周期组件](/web/20220925022810/https://www.netguru.com/blog/android-components-comparison-mvvm-vs-mvp)和 现在，我们将深入研究 Room Persistence Library，它有可能成为本地存储的新改进——不仅因为它的受欢迎程度，还因为您在使用它时会发现两者之间的相似之处。

## 老办法

目前，clean SQLite 几乎被遗忘，并不真正存在于商业项目中。尽管它仍然是官方文档推荐的唯一数据库解决方案，并能让您很好地(如果不是最好的话)控制本地存储，但是使用它的代价太高了。原因是开发人员最终会产生大量样板文件，编写所有的查询，然后将它们转换成 Java 对象。对于没有 SQL 知识的人来说，这可能是个问题，更不用说缺少对任何反应组件的默认支持，而这正是一些 ORM 的巨大优势。

在编写 SQL 查询的过程中，错误是不可避免的，最糟糕的是，直到你编译你的应用程序并尝试执行你的查询时，你才会知道这些错误。其中一些问题已经在 SQLBrite 和 SQLDelight 等流行的库中解决了，但是使用这些库仍然不容易，学习曲线是指数级的。正因为如此，Android 上与持久性相关的库的数量很大，我们的选择太多了。

在 Netguru，我们测试了许多可用的解决方案，作为这项研究的结果，我们主要选择了 Realm 和 greenDAO，它们成为了我们默认堆栈的一部分。我们接受了它们的优点，也接受了它们的缺点，但是随着时间的推移，新的解决方案不断出现，所以我们决定测试 Room。

## 你知道翻新吗？房间将是小菜一碟。

就像 retrieve 在 HTTP 调用上构建抽象一样，Room 在 SQL 查询上构建抽象。要创建一个改型并设置一个客户端，您使用 *改型。* 建造者()。通过使用客户端，您可以通过调用*reflect . create(...)* 并简单地为它提供一个描述你的调用的接口，这是使用各种注释完成的。

Room 采取了类似的方法，但是 DAO 接口注册在一个扩展 RoomDatabase 的类中。然后通过调用 Room.databaseBuilder(...)并传递一个扩展 RoomDatabase 的抽象类。Room 将生成您的接口的正确实现，就像 retrieve 所做的那样，您将能够通过由构建器返回的数据库类的实现来访问这些接口。通过为远程和本地存储访问定义相同的接口，甚至可以在翻新和房间之间共享数据访问接口。

尽管如此，这并不是一个有趣的事实，因为它在很少的情况下会工作得很好，而且你应该知道这个解决方案的缺点和限制，我将在本文的第二部分中分享[。就像翻新一样，Room 提供了对 RxJava2 的支持。](/web/20220925022810/https://www.netguru.com/blog/check-out-why-room-is-a-retrofit-for-sqlite-pt.-2)

## 房间能做什么？

它将为您执行查询并将查询转换为 Java 对象，其方式可能类似于您从 Retrofit 和 Gson 中了解到的方式。它将为您创建表，因此不再需要创建表查询。它将允许您轻松地构建反应式数据流。

## 房间不能做什么？

Room 不会为您处理对象引用(尽管可以通过对我们的类类型使用@Embedded 注释将对象嵌入到表中)。这是房间设计的一个特点，所以不允许放置任何反映对象之间关系的字段-必须通过引用主键来完成。

在我们的例子中，这意味着我们不能在 TaskDb 中创建一个 ChecklistItemDb 的列表来反映我们的一对多关系。为什么？一些 ORM(比如 greenDAO，它允许您创建对象依赖关系)是延迟初始化的，其结果是当您调用 getter 返回关系中的另一个对象时，您实际上是在进行另一个查询。糟糕的设计可能会导致开发人员或代码审查人员甚至没有注意到在 UI 线程上进行这样的调用，我们都知道进行这样的调用不是一个好主意，因为它可能会导致帧率下降。

实际上，对于 UI 线程上的调用，Room 得到了很好的保护，默认情况下，你不能进行任何调用——如果你敢这样做，就会抛出一个异常，导致崩溃。这就是 RxJava 派上用场的地方，因为它允许轻松地将所有工作委托给另一个线程，这也是我将在第 2 部分中介绍的方法。当然，选择权在你，你可以使用你所知道的任何其他解决方案。

另一件 Room 不会阻止你做的事情是编写 SQL 查询，但由于内置的注释和编译时检查，它们会少得多，而且会更友好。这将让您毫无争议地体验 SQLite 的全部功能。

## 还有更多

我们介绍了 Room 的基本功能及其与翻新的相似之处，但这并不是全部。在第 2 部分中，我们将深入探讨实现细节，一些问题和我们在实现示例应用程序时发现的 Room 的酷功能(将与本文的第 2 部分[一起发布](/web/20220925022810/https://www.netguru.com/blog/check-out-why-room-is-a-retrofit-for-sqlite-pt.-2))。