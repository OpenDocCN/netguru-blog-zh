<html>
<head>
<title>Android Jetpack Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Android Jetpack安全性</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/androidx-security#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/androidx-security#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>介绍</p><p>安全性无疑是移动应用程序中的一个重要元素，但不幸的是，正确地做每件事是一项复杂的任务。最近，谷歌发布了其安全加密库，作为<a href="http://web.archive.org/web/20221205003721/https://developer.android.com/jetpack" rel="noopener" target="_blank"> jetpack组件</a>的一部分，以简化使应用程序更加安全的过程。</p></div><p>目前，该库包括三个主要功能:</p>
<ul>
<li>万能钥匙</li>
<li>EncryptedSharedPreferences</li>
<li>加密文件</li>
</ul>
<p>AndroidX Security正在使用幕后的Tink库。Tink是Google创建的一个开源加密库，提供加密API。</p>
<h2>装置</h2>
<p>要使用这个库，你只需要将这一行添加到应用程序的Gradle文件中:</p>
<pre><code class="language-gradle">implementation `androidx.security:security-crypto:1.0.0-alpha02`</code></pre>
<p>Security-crypto目前处于alpha版本，但你可以在<a href="http://web.archive.org/web/20221205003721/https://mvnrepository.com/artifact/androidx.security/security-crypto?repo=google" rel="noopener" target="_blank"> mvnrepository页面</a>上监测它的新版本。它的大小真的很小——在分析了它在<code>11.9 KB</code>附近添加的编译过的<code>.apk</code>文件之后。</p>
<p>为了使用这个库，您需要将<code>minSdkVersion</code>设置为<code>23+</code>——由于使用了新的API，Keystore操作特别稳定(<code><a href="http://web.archive.org/web/20221205003721/https://developer.android.com/reference/android/security/KeyPairGeneratorSpec" rel="noopener" target="_blank">KeyPairGeneratorSpec</a></code>已经被API 23 <code><a href="http://web.archive.org/web/20221205003721/https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec" rel="noopener" target="_blank">KeyGenParameterSpec</a></code>取代)。</p>
<h2>万能钥匙</h2>
<p><code>MasterKeys</code>是一个包含一个公共方法<code>getOrCreate</code>的助手类，该方法允许开发者创建一个主密钥，然后为它获得一个别名。让我们分析一下代码:</p>
<pre><code class="language-java">@NonNull
public static String getOrCreate(
        @NonNull KeyGenParameterSpec keyGenParameterSpec)
        throws GeneralSecurityException, IOException {
    validate(keyGenParameterSpec);
    if (!MasterKeys.keyExists(keyGenParameterSpec.getKeystoreAlias())) {
        generateKey(keyGenParameterSpec);
    }
    return keyGenParameterSpec.getKeystoreAlias();
}
</code></pre>
<p>唯一的参数<code>KeyGenParameterSpec</code>指定了算法、块模式、填充和密钥大小等选项。放置在<code>MasterKeys.AES256_GCM_SPEC</code>下的默认值创建以下对象:</p>
<pre><code class="language-kotlin">
@NonNull
private static KeyGenParameterSpec createAES256GCMKeyGenParameterSpec(
        @NonNull String keyAlias) {
    KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(
            keyAlias,
            KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
            .setKeySize(KEY_SIZE);
    return builder.build();
}
</code></pre>
<p>其中<code>keyAlias</code>是<code>_androidx_security_master_key_</code>和<code>KEY_SIZE = 256</code>。</p>
<h2>EncryptedSharedPreferences</h2>
<p><code>EncryptedSharedPreferences</code>是<code>SharedPreferences</code>的一个包装类，它允许你保存和读取加密和解密的值。让我们看看如何创建它的一个实例:</p>
<pre><code class="language-kotlin">EncryptedSharedPreferences.create(
    PREFS_FILENAME,
    masterKeyAlias,
    applicationContext,
    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
)</code></pre>
<p>第二个参数是使用<code>MasterKeys.getOrCreate(KeyGenParameterSpec)</code>创建的别名，最后两个参数定义了用于加密密钥和值的方案。目前，唯一可用的<code>EncryptedSharedPreferences.PrefKeyEncryptionScheme</code>是<code>AES256_SIV</code>，唯一可用的<code>EncryptedSharedPreferences.PrefValueEncryptionScheme</code>是<code>AES256_GCM</code>。</p>
<p>然后我们能够像使用一个典型的<code>SharedPreferences</code>对象一样使用它。下面是保存一个<code>String</code>的例子:</p>
<pre><code class="language-kotlin">encryptedPrefs.edit {
    putString(ENC_KEY, value)
    apply()
}
</code></pre>
<p>并读取保存的值:</p>
<pre><code class="language-kotlin">val string = encryptedPrefs.getString(ENC_KEY, null)
</code></pre>
<p>下面是一个简短的视频，展示了它在我的例子中是如何工作的:</p>
<p>加密文件</p><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221205003721im_/https://www.netguru.com/hs-fs/hubfs/android_security_prefs.gif?width=300&amp;name=android_security_prefs.gif 300w, http://web.archive.org/web/20221205003721im_/https://www.netguru.com/hs-fs/hubfs/android_security_prefs.gif?width=600&amp;name=android_security_prefs.gif 600w" src="../Images/169a1951f6db33a8dd9c7f740721a92f.png" alt="android_security_prefs" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221205003721im_/https://www.netguru.com/hs-fs/hubfs/android_security_prefs.gif?width=300&amp;name=android_security_prefs.gif"/>
  </figure><p><code>EncryptedFile</code>允许您使用<code>FileInputStream</code>轻松加密数据，使用<code>FileOutputStream</code>轻松解密。要创建它的实例，我们需要几样东西:</p>
<h2>第一个参数是一个<code>File</code>对象，它定义了存储加密数据的路径和名称。在我的例子中，我创建了一个这样的实例:</h2>
<p>使用<code>masterKeyAlias</code>与在<code>EncryptedSharedPreferences</code>例子中完全一样。最后一个参数<code>fileEncryptionScheme</code>定义了输入/输出流应该如何加密或解密的方案。目前唯一可用的值是<code>AES256_GCM_HKDF_4KB</code>。下面，我列举了一些关于它的细节:</p>
<pre><code class="language-kotlin">EncryptedFile.Builder(
    file,
    applicationContext,
    masterKeyAlias,
    EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB
).build()
</code></pre>
<p>主键的大小:32字节</p>
<pre><code class="language-kotlin">val file = File(filesDir, ENCRYPTED_FILE_NAME)
</code></pre>
<p>HKDF算法:HMAC-SHA256</p>
<ul>
<li>AES-GCM派生密钥的大小:32字节</li>
<li>密文段大小:4096字节</li>
<li>出于示例目的，我决定从示例存储库中下载<code>README.md</code>文件，使用<code>OkHttp</code>库可以访问<a href="http://web.archive.org/web/20221205003721/https://raw.githubusercontent.com/stramek/Android-Security-Playground/master/README.md" rel="noopener" target="_blank">这里的</a>，从响应<code>response.body!!.bytes()</code>中获取字节，然后通过将这些字节传递给以下方法来保存它:</li>
<li>然后读它:</li>
</ul>
<p>为了加密和加载下载的文件内容，我调用了:</p>
<pre><code class="language-kotlin">private fun onFileDownloaded(bytes: ByteArray) {
    var encryptedOutputStream: FileOutputStream? = null
    try {
        encryptedOutputStream = encryptedFile.openFileOutput().apply { 
            write(bytes) 
        }
    } catch (e: Exception) {
        Log.e(„TAG”, „Could not open encrypted file”, e)
    } finally {
        encryptedOutputStream?.close()
    }
}
</code></pre>
<p>要在不加密的情况下加载文件以确保数据在不解密的情况下不可读，请执行以下操作:</p>
<pre><code class="language-kotlin">private fun readFile(fileInput: () -&gt; FileInputStream) {
    var fileInputStream: FileInputStream? = null
    try {
        fileInputStream = fileInput()
        val reader = BufferedReader(InputStreamReader(fileInputStream))
        val stringBuilder = StringBuilder()
        reader.forEachLine { line -&gt; stringBuilder.appendln(line) }
        result.text = stringBuilder.toString()
    } catch (e: Exception) {
        Log.e(„TAG”, „Error occurred when reading file”, e)
    } finally {
        fileInputStream?.close()
    }
}
</code></pre>
<p>以下是示例中展示其工作原理的视频:</p>
<pre><code class="language-kotlin">readFile { encryptedFile.openFileInput() }
</code></pre>
<p>示例项目</p>
<pre><code class="language-kotlin">readFile { file.inputStream() }
</code></pre>
<p>工作代码可以在下面的库<a href="http://web.archive.org/web/20221205003721/https://github.com/stramek/Android-Security-Playground" rel="noopener" target="_blank">这里</a>找到。</p>
<p>摘要</p><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221205003721im_/https://www.netguru.com/hs-fs/hubfs/android_security_enc_file.gif?width=300&amp;name=android_security_enc_file.gif 300w, http://web.archive.org/web/20221205003721im_/https://www.netguru.com/hs-fs/hubfs/android_security_enc_file.gif?width=600&amp;name=android_security_enc_file.gif 600w" src="../Images/d7ac87b74d65c0d94000630892e29aa1.png" alt="android_security_enc_file" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221205003721im_/https://www.netguru.com/hs-fs/hubfs/android_security_enc_file.gif?width=300&amp;name=android_security_enc_file.gif"/>
  </figure><p>AndroidX Security巧妙地包装了复杂的安全逻辑，同时向开发人员公开了简单的接口。有了这个库和几行代码，就有可能使我们的应用程序更加安全，并消除开发人员忘记一些关键配置的情况。唯一的缺点是，它迫使开发者只能让应用程序兼容android Marshmallow和更新的版本，但记住关于<code>KeyGenParameterSpec</code>和<code>KeyPairGeneratorSpec</code>的背景故事，这个决定是合理的。此外，根据谷歌提供的<a href="http://web.archive.org/web/20221205003721/https://developer.android.com/about/dashboards" rel="noopener" target="_blank">分布仪表板</a>，世界上只有四分之一的设备使用Android 5或更旧版本，这个数字随着时间的推移正在急剧下降。我们仍然需要记住，加密项目中的<code>SharedPreferences</code>和文件是让应用程序真正安全的众多因素之一。让我们为这个库的稳定发布祈祷吧。</p>
<h2> </h2>
<p><span>照片由</span> <a href="http://web.archive.org/web/20221205003721/https://unsplash.com/@chrispanas" rel="noopener" target="_blank">克里斯·帕纳斯</a> <span>在</span> <a href="http://web.archive.org/web/20221205003721/https://unsplash.com/" rel="noopener" target="_blank"> Unsplash </a></p>
<h2>Summary</h2>
<p>AndroidX Security cleverly wraps complex security logic while exposing simple interfaces to developers. With this library and a few lines of code, it’s possible to make our application more secure and eliminate cases where the developer forgets about some crucial configuration. The only downside is that it forces the developer to make the application compatible with android Marshmallow and newer only, but keeping in mind the backstory about <code>KeyGenParameterSpec</code> and <code>KeyPairGeneratorSpec</code>, this decision is reasonable. Also, according to the <a href="http://web.archive.org/web/20221205003721/https://developer.android.com/about/dashboards" rel="noopener" target="_blank">distribution dashboard</a> provided by Google, only a quarter of devices in the world use Android 5 or older and this number is drastically decreasing over time. We still need to remember that encrypting <code>SharedPreferences</code> and files in a project are one of many factors that make the app truly secure. Let's keep our fingers crossed for a stable release of this library soon.</p>
<p> </p>
<p><span>Photo by </span><a href="http://web.archive.org/web/20221205003721/https://unsplash.com/@chrispanas" rel="noopener" target="_blank">Chris Panas</a><span> on </span><a href="http://web.archive.org/web/20221205003721/https://unsplash.com/" rel="noopener" target="_blank">Unsplash</a></p></span></div>    
</body>
</html>