<html>
<head>
<title>Kotlin Multiplatform Guidelines. Common Modules Versioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>科特林多平台指南。通用模块版本控制</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/kotlin-multiplatform-guidelines.-common-modules-versioning#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/kotlin-multiplatform-guidelines.-common-modules-versioning#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h2"><p>这篇关于Kotlin多平台指南的评论将集中在项目架构和设计方面。</p></div><h2>项目模块化的动机</h2>
<p>Kotlin Multiplatform使得维护一个包含不同目标平台共享代码的项目成为可能，这些平台包括<em>后端</em>、<em> web前端</em>、<em> Android </em>和<em> iOS </em>应用等等。这就是为什么这种多平台项目需要高度模块化的原因:</p>
<ol>
<li>
<p>为了达到令人满意的代码可重用性</p>
</li>
<li>
<p>为一个大而复杂的项目提供一个清晰的架构</p>
</li>
</ol>
<p>在不同的目标之间共享代码有很多好处。在通用后端-前端代码的情况下，好处是用于数据通信的数据模型的一致性。对于Android、iOS和web前端，所有这些目标都可以共享一个<em>业务逻辑</em>层，负责诸如<em>用户输入检测和处理</em>、<em>网络通信</em>、<em>数据处理、数据持久化</em>之类的事情。UI层应该为每个平台单独实现。</p>
<p>还可能需要将一些额外的多平台代码提取到一个模块中，该模块包含其他不同项目模块所需的实用函数和通用类型模型。它们可以被提取并保存在项目之外，并作为外部多平台依赖项进行链接。</p>
<br/>
<h2>模块版本化的需求</h2>
<p>为了使各种平台相关模块的同时开发成为可能，需要引入公共(共享)模块的版本控制。</p>
<figure class="image&#10;    &#10;    image--framed&#10;    " data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929101222im_/https://www.netguru.com/hs-fs/hubfs/Screenshot%202019-02-15%20at%2019.01.40.png?width=300&amp;name=Screenshot%202019-02-15%20at%2019.01.40.png 300w, http://web.archive.org/web/20220929101222im_/https://www.netguru.com/hs-fs/hubfs/Screenshot%202019-02-15%20at%2019.01.40.png?width=600&amp;name=Screenshot%202019-02-15%20at%2019.01.40.png 600w" src="../Images/87e3c0e1d63ca2b775760167a53a3a21.png" alt="Screenshot 2019-02-15 at 19.01.40" loading="lazy" data-original-src="http://web.archive.org/web/20220929101222im_/https://www.netguru.com/hs-fs/hubfs/Screenshot%202019-02-15%20at%2019.01.40.png?width=300&amp;name=Screenshot%202019-02-15%20at%2019.01.40.png"/>
  </figure><br/>
<p>让我们考虑下面这个包含3个模块的项目的例子:<em> A </em>、<em> B </em>、<em> C </em>，其中A由<em> B </em>和<em> C </em>平台相关模块使用的共享业务逻辑代码组成。</p>
<p><em> B </em>和<em> C </em>模块正在内部使用<em> A </em>模块依赖关系。来自<em> A </em>模块的共享代码被相应地编译到目标平台(例如Android的jar文件、iOS的框架或静态库)并链接到最终产品。每当对由<em> A </em>模块公开并推送到主分支的API进行一些更改时，都需要立即修改<em> B </em>和<em> C </em>模块，以便允许构建整个项目。因此，如果<em> B </em>和<em> C </em>模块紧密耦合</p><figure class="image&#10;    &#10;    image--framed&#10;    " data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929101222im_/https://www.netguru.com/hs-fs/hubfs/Screenshot%202019-02-15%20at%2019.01.46.png?width=300&amp;name=Screenshot%202019-02-15%20at%2019.01.46.png 300w, http://web.archive.org/web/20220929101222im_/https://www.netguru.com/hs-fs/hubfs/Screenshot%202019-02-15%20at%2019.01.46.png?width=600&amp;name=Screenshot%202019-02-15%20at%2019.01.46.png 600w" src="../Images/037bdcd3b753a9bd8f4b0867eb70dc2f.png" alt="Screenshot 2019-02-15 at 19.01.46" loading="lazy" data-original-src="http://web.archive.org/web/20220929101222im_/https://www.netguru.com/hs-fs/hubfs/Screenshot%202019-02-15%20at%2019.01.46.png?width=300&amp;name=Screenshot%202019-02-15%20at%2019.01.46.png"/>
  </figure> the latest <em>A</em> module state the project is impossible to maintain as a whole. To make the development more flexible the changes made to the <em>A </em>module should be released as the versioned artifacts without a need to adopt all the dependent modules immediately.<p>正在运行的模块版本控制</p>
<p>发布到Maven本地存储库</p>
<h2><strong>kot Lin-多平台</strong> Gradle插件与标准Gradle <strong> maven-publish </strong>插件配合良好:</h2>
<h2>上面的配置足以在本地提供无痛苦的版本控制和模块工件的发布。模块工件发布在本地maven存储库目录下(~/.m2)。</h2>
<p>将工件发布到maven本地存储库对于新模块版本的开发和测试来说是完美的。</p>
<pre>apply plugin: 'maven-publish'<br/><br/>// Publication metadata<br/>version '0.0.1'<br/>group 'com.netguru.papersoccer'</pre>
<p>发布到Bintray存储库</p>
<p>当一个模块的新版本准备好发布的时候，就该把它上传到一个外部存储库了。这是允许在项目的其他层中集成新的模块版本，并使项目在CI上成功构建所必需的。</p>
<h2>在与Kotlin Everywhere工作组下的项目合作时，我们使用Bintray存储库来上传准备好的工件。下面的<strong> publish-bintray.gradle </strong>脚本应用于每个项目模块。</h2>
<p>使用<strong>调用上传。/gradlew bintrayUpload </strong>命令。它负责构建项目，生成正确的工件，最后将其上传到Bintray maven存储库。</p>
<p>为了给模块公开的API提供文档，可以使用KDoc<a href="http://web.archive.org/web/20220929101222/https://kotlinlang.org/docs/reference/kotlin-doc.html">https://kotlinlang.org/docs/reference/kotlin-doc.html</a>。</p>
<p>多平台库工件架构</p>
<p>Kotlin-multiplatform插件允许为以下一组平台构建共享库:</p>
<h2>Java虚拟机-标准。jar文件</h2>
<p>Android VM -目前(2019年1月)存在生成问题。使用kotlin-multiplatform插件的aar Android库和一些实现它所需的工具(更多细节可在下面的链接中获得:<a href="http://web.archive.org/web/20220929101222/https://youtrack.jetbrains.com/issue/KT-27535">https://youtrack.jetbrains.com/issue/KT-27535</a></p>
<ol>
<li>
<p>Kotlin/Native (iOS、x86、STM32目标)。klib包是为iOS等原生平台生成的。Klib本机库工件可以链接到其他kotlin多平台和平台本机模块。更多信息请点击这里:<a href="http://web.archive.org/web/20220929101222/https://kotlinlang.org/docs/tutorials/native/working-with-klib.html">https://kotlinlang . org/docs/tutorials/native/working-with-klib . html</a></p>
</li>
<li>
<p>kot Lin-多平台插件与maven-publish插件无缝集成。它为模块级构建脚本中定义的每个目标自动生成适当的工件。</p>
</li>
<li>
<p>Netguru Kotlin多平台项目示例</p>
</li>
</ol>
<br/>
<p><a href="http://web.archive.org/web/20220929101222/https://github.com/netguru/KotlinMultiplatformStorage">https://github.com/netguru/KotlinMultiplatformStorage</a></p>
<h2>Netguru Kotlin Multiplatform project examples</h2>
<ol>
<li>
<p><a href="http://web.archive.org/web/20220929101222/https://github.com/netguru/KotlinMultiplatformStorage">https://github.com/netguru/KotlinMultiplatformStorage</a></p>
</li>
</ol></span></div>    
</body>
</html>