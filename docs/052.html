<html>
<head>
<title>How to Implement Devise with 2-factor Authentication: Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何实现双因素身份验证:教程</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/devise-with-2-factor-auth#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/devise-with-2-factor-auth#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>最近，我不得不在一个Rails应用程序中创建一个简单的特性——双因素认证(2FA)。我开始做了一些快速的研究，看看网上有什么推荐的，并思考它如何适合我们在Netguru的项目。了解我如何在Devise中提出双因素身份认证解决方案。</p></div><p/>
<p>我对我的搜索结果不太满意2FA的话题肯定没有design本身讨论得广泛，虽然有许多可能的选项，但只有少数几个得到了很好的描述。因此，我认为写一篇博客文章，简要总结我的研究以及我最终认定的最佳解决方案，会有所帮助。</p>
<h3>使用Twilio和Authy的双因素认证设计</h3>
<p><strong>假设</strong>:你已经设计好并开始工作。你想要的只是在短信的基础上增加2FA来扩展它。</p>
<p>Authy 是一个付费产品，所以很自然地期望他们提供非常好的文档和教程。在这里你会发现一篇关于将Authy与你的应用程序整合的<a href="http://web.archive.org/web/20221205021113/https://www.twilio.com/blog/2016/01/two-factor-authentication-in-rails-4-with-devise-authy-and-puppies.html" rel="nofollow" target="_blank">优秀博文。</a></p>
<ul>
<li>优点:集成只需要很少的时间——只需要几行代码就可以完成基本的设置。</li>
<li><strong>缺点</strong>:它只处理Authy，而且相当贵——每次需要短信的认证要0.09美元(如果用户保存了设备，就不再需要了)，每次发送短信要0.05美元。然而，如果你所需要的只是验证你的MVP，那就尽快行动，稍后再支付<em/>也很好。</li>
</ul>
<h3>设计与双因素认证使用谷歌认证-没有短信支持</h3>
<p><strong>假设</strong>:你已经设计好并开始工作。你想要的只是在Google Authenticator的基础上添加2FA来扩展它。</p>
<p><strong>谷歌认证器</strong>是集成双因素认证的众多可能选项之一。它是免费的，所以经常使用。你可以想象，有一块宝石。在这里你可以阅读<a href="http://web.archive.org/web/20221205021113/https://labs.asteriskinfosec.com.au/integrating-googles-2nd-factor-authentication-with-your-rails-app/" rel="nofollow" target="_blank">如何整合<code>devise_google_authenticator</code>宝石</a>。</p>
<ul>
<li><strong>优点</strong>:非常容易集成。</li>
<li>缺点:不支持短信服务，而且在默认情况下，你可以随意定制。</li>
</ul>
<h3>采用Twilio - SMS(可选)和Google Auth(定制)支持的双因素身份验证设计</h3>
<p><strong>假设</strong>:你已经设计好并开始工作。你想在SMS和Google Authenticator的基础上增加2FA来扩展，又不想用Authy(由于其价格原因)。下面的方法是可行的，可定制的，快速的，但是可能需要更多的调整，主要是在用户体验方面。</p>
<p>这个教程是我做的，旨在为你提供一个定制2FA的有据可查的方法。实现全部功能不会花费你超过2-3个小时——如果需要更长时间，或者你有不明白的地方，<a href="http://web.archive.org/web/20221205021113/https://twitter.com/jakubniechcial" rel="nofollow" target="_blank">请在Twitter上告诉我</a>。</p>
<p><strong>我们将使用什么:</strong></p>

<p>你还需要一个Twilio账户。你可以<a href="http://web.archive.org/web/20221205021113/https://www.twilio.com/" rel="nofollow" target="_blank">注册</a>并简单使用一个试用账户(但仅限于开发！).</p>
<h3>安装双因素身份验证</h3>
<p><span>首先，你需要按照<a href="http://web.archive.org/web/20221205021113/https://github.com/Houdini/two_factor_authentication" rel="nofollow" target="_blank">自述文件</a>安装<code>two_factor_authentication</code>宝石。安装运行迁移，向您的模型添加一些必要的列，向device<code>User</code>类添加策略。</span></p>
<p><span>此外，您应该将<code>has_one_time_password(encrypted: true)</code>方法添加到负责遵守Devise的用户类中。</span></p>
<p><span>看看<a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/e5ddde360ea8b7692234319d9015b42615743840" rel="nofollow" target="_blank">提交</a> <code>two_factor_authentication</code>安装所需的代码。</span></p>
<h3>设置您的模型</h3>
<p>假设您已经正确配置了Devise，那么您必须向您的<code>User</code>模型添加几个必要的列:</p>
<ul>
<li><span> <code>two_factor_enabled</code>作为一个简单的标志来处理特定用户的2FA</span></li>
<li>这将指出用户已启用2FA，但没有通过提供正确的代码(来自SMS或Google授权者)进行确认；</li>
<li><code>phone_number</code>处理用户的电话号码。</li>
</ul>
<p><span>看一看<a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/74dc241fff04c9421d473f138850cf054586ea60" rel="nofollow" target="_blank">这次迁徙</a>。</span></p>
<p><span>你需要定义一个方法来告诉Devise什么时候使用两个因子——这叫做<code>need_two_factor_authentication</code>。如果帐户已启用双因素身份验证并已确认使用(通过安装Google Authorizer应用程序或提供有效的确认电话号码),此方法将返回<code>true</code>。想看看例子吗？<a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/80640c1c7f59820ebd094cf56477a2902d99d232" rel="nofollow" target="_blank">好了</a>！</span></p>
<p><span>接下来，我们需要定义一些逻辑来处理<code>unconfirmed_two_factor</code>列。双因素身份验证的确认应该设置为on -当启用状态从false变为true时，或者当启用了2FA身份验证的电话号码发生变化时。</span></p>
<p><span>让我们把它包在<code>ActiveModel</code>回调<code>before_save</code> : </span>中</p>
<p data-gist-id="9c5b1c346b5746969f1ca7c94dbd4a7c"> </p>
<h3>扩展您的设备注册编辑视图</h3>
<p>在这个例子中，我们将把用户编辑建立在基本设计表单的基础上。您可以在不同的视图中将这种行为扩展到其他控制器，但想法将保持不变。</p>
<p>首先，您必须允许“设计更新帐户”操作的参数。您还需要生成Devise视图，并通过添加表单输入来扩展它们。最后，记得在<code>routes.rb</code>文件的<code>devise_for</code>声明中定义<code>controllers</code>键。</p>
<p>这三个步骤的代码可在本报告中<a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/10ff4d093bd9b45f4988e2eee5a94cffec799da0" rel="nofollow" target="_blank">获得。</a></p>
<h3>处理确认流程</h3>
<p>您可能不知道，但是双因素身份验证的整体思想是标准化的(嗯，就像OAuth一样)。它基本上是一个基于特定密钥/秘密/当前时间生成N长度代码的协议。Google Authenticator是一个移动应用程序，允许用户通过QR码获取密钥(秘密仍然隐藏在您的服务器上)，并基于该密钥，每30秒生成一个新代码。基本上，它不需要在第一次初始化后连接到你的应用程序，谷歌认证器生成的每个代码都将在30秒内有效。</p>
<p>首先，我们将添加<a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/4398e6a38a323b56988f230a8083122ed3c1945f" rel="nofollow" target="_blank">一个非常基本的方法，通过它的API </a>渲染一个Google就绪的二维码(不需要API键)。那么，确认流程会是什么样的呢？每当用户更改设置并保存时，一个设计动作将执行<code>after_update_path_for</code>方法来重定向用户。我们将覆盖这个方法，并基于当前的<code>unconfirmed_two_factor</code>状态，将用户重定向到<code>root</code>或我们闪亮的新确认表单。<strong> <span> <a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/30fdb2444a38889d7f544caf88f24bc66489186e" rel="nofollow" target="_blank">看它工作并检查代码</a> : </span> </strong></p>
<p data-gist-id="70c63672cbe9e1d8d0009e105705287f"> </p>
<p><span>然后，我们将在<code>RegistrationsController</code>中创建两个动作——一个用于呈现QR代码，一个用于从Google Authorizer输入代码的简单输入；第二个处理表单、验证代码并更新当前用户对象。</span> <a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/0793ab591d293479f94ea1acc623adfee27c0434" rel="nofollow" target="_blank">这两个动作，以及它们的视图和路由器，都可以在这里找到</a>。</p>
<p>我们如何验证用户提供的代码是有效的？<code>two_factor_authentication</code> gem提供了一个简单的方法，叫做<code>authenticate_otp</code>，它接受参数中的代码并验证它。我们将定义并使用<code>User</code>类上的方法，如果传递的代码有效，该方法将更新模型。</p>
<p><span> <a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/713addf4ba56e655ab7dcca8a7ae3f523942701c" rel="nofollow" target="_blank">见此法此处</a> : </span></p>
<p data-gist-id="4649b5310cbb67ec917cbe0c3690a2cb"> </p>
<p>最后，但同样重要的是，我们可以对我们的应用程序进行一些调整。首先，让我们呈现一个flash消息，通知用户他们必须尽快确认双因素流程。让我们在标题中添加一个到用户编辑页面的链接。 <a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/283c8ed76a1b87699c478e22e1cde527de6378f5" rel="nofollow" target="_blank">很简单吧</a>？</p>
<h3>将Twilio添加到此流程中</h3>
<p>我们仍然没有使用Twilio或SMS。目前，用户进行双因素身份验证的唯一方式是使用Google Authenticator。现在，让我们添加通过SMS发送代码的功能，作为Google Authenticator的替代方案。我们将安装<code>twilio-ruby</code>——Twilio API的Ruby包装器。一旦完成，我们需要做的就是覆盖<code>User</code>类中的<code>send_two_factor_authentication_code</code>方法，该类由<code>two_factor_authentication</code> gem提供，默认为空。我们将检查<code>phone_number</code>是否存在，如果存在，则发送一条带有当前双因素代码(实时生成)的消息。<strong> <span> <a href="http://web.archive.org/web/20221205021113/https://github.com/netguru/devise-2fa/commit/7bb69edd14613cd3006364da649e43acf9cda886" rel="nofollow" target="_blank">见完整提交</a>及摘录此处:</span> </strong></p>
<p data-gist-id="cc9fc7326ff8192d368a472daed75782"> </p>
<p><span>你注意到<code>rescue</code>区块了吗？我们没有任何电话验证，我也不太喜欢它——这相当困难，因为不同的用户以许多不同的方式输入电话号码，比如<code>+48 123-456-789</code>、<code>123456789</code>、<code>123 456 789</code>等等。因此，我们选择忽略电话号码的有效性，除非Twilio发送短信有问题。如果发生这种情况，我们只需呈现一个带有适当警告的flash消息。用户仍然可以使用Google Authenticator，或者只是返回到编辑用户页面并更改电话号码。</span></p>
<h3>摘要</h3>
<p>我对双因素身份认证的快速研究表明，仍然有一些主题没有得到很好的描述。本教程不是对2FA策略的深入探索，而是旨在让该特性发挥作用的快速介绍。</p>
<p><strong> <span> <strong> <span>那教程呢？我们已经构建了两种可能处理2FA的方法的基本实现——通过SMS和通过Google Authenticator。让它们工作并不需要太多的努力。如果你有不明白的地方，或者教程花了你超过2-3个小时，请告诉我！</span> </strong> </span> </strong></p></span></div>    
</body>
</html>