# 如何避免 Ember.js 中 Mixins 之间共享状态| ember . js 上的 Netguru 博客

> 原文：<http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/how-to-avoid-shared-states-between-mixins-in-ember.js>

 就我个人而言，我经常使用 mixins。在他们的帮助下，我们可以轻松地分离一个对象中的职责(无论是控制器、组件还是其他东西)，他们让我们以可重用的方式设计应用程序的架构。混合可以使我们的代码更干净，但是它们也带来了在多个对象之间共享状态的危险。您甚至可能没有意识到这一点，因为这种情况并不常见，但是如果发生这种情况，查找该 bug 可能会花费您几个小时的时间——所以最好做好准备！

## Ember.js 中 Mixins 之间的共享状态

### 什么是共享状态？

我说的共享状态是什么意思？假设我们有两个组件，都存储一个列表，其中一个是“任务”，另一个是“要购买的物品”。我们决定将存储该列表的数组提取到一个 mixin 中(这可能看起来有点过分，但这只是一个例子！):

接下来，我们创建两个组件，它们能够添加一个新任务或具有预定义名称的购物项目。[看看这个 Ember Twiddle](http://web.archive.org/web/20201108144254/https://ember-twiddle.com/47bfc4020af5fb720d70) 看看现场演示，玩玩添加项目。

如您所见，看起来它们共享同一个数组实例，这导致了错误的行为。这个 bug 很容易发现，但是假设你已经渲染了两个完全不同的组件，它们通过一个 mixin 以两种不同的方式分担部分责任。对于一些用户来说，应用程序会在访问第二条路线后在第一条路线上崩溃，而对于另一些用户来说，会在访问第一条路线后在第二条路线上崩溃。此外，很难重现车祸。

### 为什么会这样？

首先，我们来试着了解一下为什么会出现这种情况。如果我们更熟悉面向对象编程而不是原型继承，我们可能会认为创建两个扩展相同 mixin 的组件不可能意外地导致共享状态。当我们定义一个新的 mixin，并最终将它导入到另一个文件(比如一个组件)时，它就被创建了。在这个创建过程中，我们为`list`属性定义的数组也被创建，`list`存储了一个对这个数组的引用。当我们呼唤，比如说，`Ember.Component.extend(OurMixin, { (...) })`，我们基本上创造了一个新的灰烬。从基成员复制可枚举属性的组件实例。组件实例，来自 OurMixin 实例和来自我们定义为组件的对象(顺序最后，优先级最高)。

我们在 mixins 中定义的常规属性是可枚举的，所以`list`属性的值(对数组实例的引用)被复制到我们的组件中。同样的事情发生在我们使用 mixin 的任何其他地方——对同一个数组的相同引用被复制到一个新的对象，这就是 bug 的起源。面向对象编程中没有类对象这样的蓝图。只有第一个实例，可枚举属性从该实例复制到扩展对象。

### 通过使用计算属性避免共享状态

避免实现 mixins 的对象之间共享状态的最简单方法是用一个简单的 getter 将引用存储的对象(普通对象、数组)包装到计算的属性中:

这里，被复制的是一个函数，而不是数组引用。在每个对象中，这个计算属性将返回一个新的 Ember 实例。在第一次计算它的时候，它不会在主对象的生命周期中的任何时刻改变实例。

### 使用#init()避免共享状态

另一种避免共享状态的方法是在 mixin 的`#init`方法中定义通过引用存储的属性。

[![How NOT to Run IT Project ](img/1c2c78ec7946463376729240bc9eab31.png)](http://web.archive.org/web/20201108144254/https://cta-redirect.hubspot.com/cta/redirect/493098/0411e346-5348-468e-82db-ea1c964f49b1)

这样，每个实现 mixin 的对象都将评估自己的`#init`方法，从而创建自己的数组实例。然而，这种解决方案在忘记`this._super`方面有一点风险，并且仅仅通过扫描代码有点难以阅读。

### 包扎

Mixins 很棒，我认为它们是 [Ember](/web/20201108144254/https://www.netguru.com/services/ember-js) 中对代码维护最有用的特性之一。请确保您理解正在发生的事情，以及它如何符合 JavaScript 原型继承。

你遇到过类似的陷阱吗？你愿意分享你的经历吗？请在下面的评论中这样做！如果你喜欢我的文章，你可能也会对如何在 Ember 中添加一个 catch 博客感兴趣。