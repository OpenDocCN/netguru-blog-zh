<html>
<head>
<title>Clean Swift iOS Architectural Design with SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用SwiftUI清洁Swift iOS架构设计</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/clean-swift-with-swiftui-ios#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/clean-swift-with-swiftui-ios#0001-01-01</a></blockquote><div><div id="hs_cos_wrapper_post_body"><span><div class="blog-post__lead h3"><p>自2019年9月SwiftUI框架发布以来，大多数iOS应用程序开发人员要么等待其他人找出一种以干净的方式使用新UI库的方法，要么自己尝试。</p></div><p>在这里，我想分享一下我为自己从事的商业项目准备的方法。我想<span data-style-font-weight-bold="">继续UIKit </span>中应用的导航流程，用干净的Swift clean架构保持业务逻辑的高可测试性，而<span data-style-font-weight-bold="">尝试用SwiftUI </span>实现视图。</p>
<h2>为什么不改用纯SwiftUI？</h2>
<p>我在Swift中看到很多Redux、MVVM等知名的UI架构的架构设计模式的端口与SwiftUI一起使用。然而，他们都没有说服我，它可以用在一个相当旧的项目中，严重依赖于Objective-C中的旧组件(singletons和managers ),最重要的是,<span data-style-font-weight-bold="">仍然需要从我们添加的新场景中推送或显示用UIKit </span>编写的旧视图控制器。</p>
<p>除此之外，我试图保持项目在业务逻辑分离的情况下是可测试的，不切换到pure SwiftUI的另一个重要原因是Clean Swift已经被用作所有现代模块的主要模式。</p>
<p>如果你想知道<span data-style-font-weight-bold=""> Clean Swift架构设计模式</span>是什么，<a href="/web/20221111121043/https://www.netguru.com/blog/clean-swift-ios-architecture-pattern#:~:text=Clean%20Swift%20(VIP)%20was%20first,in%20Uncle%20Bob'sClean%20Architecture." rel="noopener" target="_blank">在阅读这篇文章之前先看看我以前的文章</a>。</p>
<h2>有哪些变化？</h2>
<p>将SwiftUI与Clean Swift  <span>一起使用<span data-style-font-weight-bold="">需要做的主要改变是</span> <span data-style-font-weight-bold=""> : </span></span></p>
<ul>
<li>
<p><em> SceneViewController </em>将保存一个对<em> SceneViewModel </em>的引用，它是我们<em>视图的数据、状态和代表的来源。</em></p>
<pre>protocol WelcomeSceneViewControllerInput: AnyObject {
    var router: WelcomeSceneRoutingLogic? { get set }
    var viewModel: WelcomeSceneViewModel? { get set }
}
</pre>
</li>
<li><em> SceneViewModel </em>是一个新类，我们可以使用Combine使SwiftUI的视图具有反应性。<br/> <pre>protocol WelcomeSceneViewDelegate: AnyObject {     func didSelectButton(_ sender: WelcomeSceneViewModel?) }  protocol WelcomeSceneViewModel {     var delegate: WelcomeSceneViewDelegate? { get set }     var text: String { get }     var buttonText: String { get } }  final class DefaultWelcomeSceneViewModel: WelcomeSceneViewModel {     var delegate: WelcomeSceneViewDelegate?     @Published private(set) var text: String     @Published private(set) var buttonText: String          init(         text: String,         buttonText: String     ) {         self.text = text         self.buttonText = buttonText     } } </pre></li>
<li><em>场景视图控制器</em>继承自<em> UIHostingController &lt;场景视图&gt; </em>，而不是继承自UIViewController。<br/> <pre>final class WelcomeSceneViewController: UIHostingController {     var interactor: WelcomeSceneViewControllerOutput?     var router: WelcomeSceneRoutingLogic?     var viewModel: WelcomeSceneViewModel? } </pre>在这里查看我的示例项目<a href="http://web.archive.org/web/20221111121043/http://welcomesceneviewcontroller.swift/" rel="noopener" target="_blank">中的使用示例。</a></li>
<li><em>场景配置器</em>获取<em>视图模型</em>并将其分配给<em>视图控制器。<br/> </em>将方法'配置好(...)'包含了许多样板代码，但只要您使用本报告中的<a href="http://web.archive.org/web/20221111121043/https://github.com/strzempa/CleanSwiftWithSwiftUI/tree/main/XcodeTemplates/CleanSwift%20%2B%20SwiftUI" rel="noopener" target="_blank">我的代码模板和为配置器模块提供的测试用例，这应该不是问题。<em> <br/> </em> <pre>protocol WelcomeSceneConfigurator {     func configured(         with viewModel: WelcomeSceneViewModel     ) -&gt; WelcomeSceneViewController }  final class DefaultWelcomeSceneConfigurator: WelcomeSceneConfigurator {     func configured(         with viewModel: WelcomeSceneViewModel     ) -&gt; WelcomeSceneViewController {<br/>        var viewModel = viewModel         let viewController = WelcomeSceneViewController(             rootView: WelcomeSceneView(viewModel: viewModel)         )         let interactor = WelcomeSceneInteractor()         let presenter = WelcomeScenePresenter()         let router = WelcomeSceneRouter()         router.source = viewController         presenter.viewController = viewController         interactor.presenter = presenter         viewController.interactor = interactor         viewController.router = router         viewController.viewModel = viewModel         viewModel.delegate = viewController         return viewController     } } </pre></a></li>
<li>我们的<em> ViewController </em>的<em>视图</em>不再从<em> UIView </em>继承，而是从SwiftUI的<em>视图继承。<br/> </em> <pre>struct WelcomeSceneView: View {     let viewModel: WelcomeSceneViewModel          var body: some View {         VStack {             Text(viewModel.text)             Divider()             Button(viewModel.buttonText) {                 viewModel.delegate?.didSelectButton(viewModel)             }         }     } } </pre></li>
</ul>
<p>如果以上片段还不够，请查看我的GitHub账户中的示例项目<a href="http://web.archive.org/web/20221111121043/https://github.com/strzempa/CleanSwiftWithSwiftUI" rel="noopener" target="_blank">。</a></p>
<h2>Clean Swift + SwiftUI总结</h2>
<h4 id="Strengths-💪-:" data-renderer-start-pos="4845">它给项目带来了什么？</h4>
<ul>
<li>用非常高的可测试性、可重用的组件实施模块化，并提取业务逻辑。</li>
<li><span>可应用于任何规模和年龄的现有项目，目标部署在iOS 14以上。</span> <span/></li>
</ul>
<h4 id="Disadvantages-and-traps-👎-:" data-renderer-start-pos="5481">带SwiftUI的Clean Swift的缺点</h4>

<p>如果您在本文的任何地方感到困惑，可能是因为我假设您已经了解了用于iOS开发的Clean Swift架构设计模式。如果你不知道，或者只是想回顾一下基础知识，请查看<a href="/web/20221111121043/https://www.netguru.com/blog/clean-swift-ios-architecture-pattern#:~:text=Clean%20Swift%20(VIP)%20was%20first,in%20Uncle%20Bob'sClean%20Architecture." rel="noopener" target="_blank">我之前的博客Clean Swift (VIP) iOS架构模式。</a></p>
<p>我的想法只是众多想法中的一个，很难说混合UIKit和SwiftUI的方法会在这些年里有什么变化。拿着它，按照你的项目需要的方式修改它。</p></span></div></div>    
</body>
</html>