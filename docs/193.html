<html>
<head>
<title>How to Wrap Arbitrary Java Class in JRuby Gem?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在JRuby Gem中包装任意Java类？</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/how-to-wrap-arbitrary-java-class-in-jruby-gem#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/how-to-wrap-arbitrary-java-class-in-jruby-gem#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>最近，我偶然发现了一个Java类，它正在执行我在开始编写我的gem时想到的任务。该课程从PDF中提取文本，同时保留文本结构。我曾经是一名Java开发人员，但是我希望我的项目仍然使用Ruby。</p></div>"Let's wrap it in JRuby gem!" - came to my mind. I started googling and found excellent tutorials on this topic. However, each of them covered wrapping jar package, rather than single class. I started looking for the solution even deeper and found answers in different places on the web. I decided to wrap it in this post.<br/><br/>So firstly, let me introduce The Java Class: <a href="http://web.archive.org/web/20221201140524/https://github.com/JonathanLink/PDFLayoutTextStripper" rel="noopener" target="_blank">PDFLayoutTextStripper</a><span>. This class is very standard (when it comes to Java world standards). One important thing that it's missing is <span>package</span> definition. Packages in java world can be translated to <span>modules</span> in Ruby. The tutorial I found, assumed every Java class is namespaced by package name - and to be honest I didn't want to change the class signature. I spotted a challenge here :)</span><p/>
<p>好，我们开始吧。我提到了宝石，对吧？但是在我们创建一个gem之前，我们需要确保我们使用的是JRuby:</p>
<p><br/> <code>❯ ruby -v<br/>jruby 9.1.12.0 (2.3.3) 2017-06-15 33c6439 Java HotSpot(TM) 64-Bit Server VM 9.0.4+11 on 9.0.4+11 +jit [darwin-x86_64]</code></p>
<p>为了创建一个gem，我采用了Bundler guide中提到的标准方法:<br/> <code>❯ bundle gem pdf-textstream # naming things is a second hardest thing in IT, right?</code> <br/>遗憾的是，因为我们将使用Java本地代码，所以我们的gem将只兼容JRuby。为了确保它只在JVM上执行，您必须修改pdf-textstream.gemspec文件并设置平台参数:<br/><span>spec . platform = ' Java '</span><br/><br/>包装器代码将驻留在<span> lib/pdf/textream.rb </span>中。让我一行一行地告诉你。<br/> <code>require "pdf/textstream/version"<br/>require "java"</code> <br/> <br/>要使用Java类(还有Java stdlib，甚至直接引用Java代码)，我们就必须要有Java模块。<br/> <br/>接下来的事情就是以ruby的方式要求Java jar:<br/><code># load jars<br/>require_relative "../../jars/pdfbox-2.0.6.jar"<br/>require_relative "../../jars/commons-logging-1.2.jar"<br/>require_relative "../../jars/fontbox-2.0.6.jar"</code><br/>那些是被引入类的依赖。当然，你必须下载它们并把它们放在‘jars’目录中，然后把它们的编译版本和你的gem一起发布。<br/> <br/>接下来重要的一行是类路径定义:<br/> <code>$CLASSPATH &lt;&lt; "#{File.expand_path(File.dirname(__FILE__))}/../../classes"<br/>module Pdf<br/> module Textstream<br/></code> <br/>类路径，对于有Java背景的人来说，相当简单明了。它是目录，JVM在其中寻找包含的库。事实上，在我们的项目中没有名为classes的目录。Java编译器会自动创建它。但是我们仍然没有编译器。<br/>可能——这不是最佳实践，但是我包含了执行以下命令的构建文件:<br/> <br/> <code>javac -d classes -cp .:./jars/pdfbox-2.0.6.jar:./jars/commons-logging-1.2.jar:./jars/fontbox-2.0.6.jar *.java</code> <br/> <br/>每次修改Java类或更改依赖项时，您都应该手动执行该命令。最后，神奇的比特。首先，将Java类复制到您的gem的根目录。然后，通过使用JRuby作为代理，我们可以引用它:<br/> <code>PDFLayoutTextStripper = JavaUtilities.get_proxy_class("PDFLayoutTextStripper")</code> <br/> <br/>我做的下一件事，是我使用的类的缩短名称空间。每个Java类都可以通过Java模块树以Ruby的方式引用:<br/> <code># change namespace<br/> PDFParser = Java::OrgApachePdfboxPdfparser::PDFParser<br/> RandomAccessFile = Java::OrgApachePdfboxIo::RandomAccessFile<br/> PDDocument = Java::OrgApachePdfboxPdmodel::PDDocument<br/> PDFTextStripper = Java::OrgApachePdfboxText::PDFTextStripper</code> <br/>为了执行类，并在位于给定路径的文件上运行它，我创建了一个静态方法:</p>
<pre><code class="language-ruby">def self.file_path_to_text(path)
    # TODO: exception handling
    pdfParser = PDFParser.new(RandomAccessFile.new(Java::JavaIo::File.new(path), "r"))
    pdfParser.parse()
    pdDocument = PDDocument.new(pdfParser.getDocument());
    pdfTextStripper = PDFLayoutTextStripper.new
    string = pdfTextStripper.getText(pdDocument);
    return string
end
</code></pre>
<p>它启动PDF阅读器，解析PDF文件，将文档传递给我们的任意类，并返回它读取的字符串。最棘手的部分是我试图将Ruby文件句柄作为参数传递给PDFParser。当然失败了。PDFParser签名需要来自Java世界的文件句柄。这对我来说是新的东西，这就是为什么我必须阅读文件“Java方式”:<span>randomaccessfile . new(Java::JavaIo::file . new(path)，" r") </span></p>
<p>还有…就是这样！您的Java类打包成宝石，随时可以使用！你可以在我的<a href="http://web.archive.org/web/20221201140524/https://github.com/mic-kul/pdf-textstream" rel="noopener" target="_blank"> GitHub回购</a>里找到宝石。请记住，它是作为概念验证而创建的，并不准备用于生产。</p>
<hr/>
<p><span>照片由<span/></span><a href="http://web.archive.org/web/20221201140524/https://unsplash.com/photos/taiuG8CPKAQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Max Nelson</a><span><span/>上<span> </span> </span> <a href="http://web.archive.org/web/20221201140524/https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"> Unsplash </a></p></span></div>    
</body>
</html>