<html>
<head>
<title>Asynchronous Coding in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python中的异步编码</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/asynchronous-coding-in-python#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/asynchronous-coding-in-python#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>异步编码并不是一个全新的概念——在过去几年中，它一直是一个大话题，但现在才被更广泛地使用。与传统的线性编程相反，在传统的线性编程中，事情遵循精确的顺序，每一步都必须在下一步开始之前完成，在异步流程中，没有一个步骤必须在前进之前完成。那么，它到底是怎么工作的呢？</p></div><p/>
<h2><span> <strong>单线程和多线程环境中的同步编程模型</strong> </span></h2>
<p><span>例如，如果您的脚本从多个不同的服务器请求数据，那么一步一步地执行指令可能会非常耗时。为什么？因为脚本在等待服务器响应时不能做任何事情，当然也不能继续下一个。</span> <span> <strong>那是一个运行在单线程中的同步程序。</strong> </span></p>
<p><span> <strong>在多线程环境</strong> </span> <span>中，你有许多线程，通常甚至更多的任务(比如请求)要处理，每个线程占用一个任务来完成。然后，无论哪个线程变得空闲和可用，都可以向下移动到下一个任务。</span></p>
<h2><span> <strong>单线程和多线程环境下的异步编程模型</strong> </span></h2>
<p>一个异步程序不需要等待请求被执行，如果那会花费太多时间的话。 <span> <strong>在单线程中，</strong> </span> <span>它会跳过第一个请求，继续下一个请求，然后再回到它跳过的那个请求，从它停止的地方继续。</span></p>
<p><span> <strong>拥有多个线程</strong> </span> <span>，一个异步程序不仅能够一次处理多个任务(称为</span> <span> <em>并发</em> </span> <span>)，还可以通过不同的线程处理同一任务。例如，一个任务可以由一个线程启动，然后由另一个线程完成——一个恰好在此刻空闲的线程。这最大化了线程利用率。</span></p>
<p>还有一件事。说到多线程环境，更不用说<span><u><strong/></u></span><span><u>-</u></span><span><u><strong>全局解释器锁定器</strong> </u> </span> <span>。说到<a href="/web/20220924162317/https://www.netguru.com/services/python-development" rel=" noopener" target="_blank"> Python </a>，这与编程语言的两个实现有关——CPython和PyPy。GIL是一个互斥体，防止多个线程同时处于执行状态。难怪它如此有争议，因为这个<a href="/web/20220924162317/https://www.netguru.com/blog/django-performance-optimization" rel=" noopener" target="_blank">成为了一个瓶颈，极大地影响了Python </a>程序的性能。那么，为什么要用呢？因为CPython扩展需要GIL提供的线程安全内存管理。它会降低程序的性能，但另一方面，它也可以避免线程之间的复杂性。</span></p>
<p>好的。所以，现在我们已经讨论了基础知识，让我们通过研究一些最重要的概念来看看异步编码是如何完成的。</p>
<h2><span> <strong>异步Python: 4亮点</strong> </span></h2>
<h2><strong> 1。Python 3.5+ asyncio -异步I/O </strong></h2>
<p><span><u><em><a href="http://web.archive.org/web/20220924162317/https://docs.python.org/3/library/asyncio.html">asyncio</a></em></u></span><span>是一个Python核心库，专门用来让异步代码更简单、可读性更好(几乎像同步代码一样)，没有任何</span> <span> <u> <em> <a href="http://web.archive.org/web/20220924162317/https://en.wikipedia.org/wiki/Callback_(computer_programming)">回调</a> </em> </u> </span> <span>。它使用async/await语法，包括如下结构:</span></p>
<ul>
<li>
<p><span> <strong>事件循环</strong></span><span>——这管理着各种任务的执行。它是负责处理输入/输出(I/O)和系统事件的中央执行器；</span></p>
</li>
<li>
<p><span> <strong>协程</strong></span><span>——这些是特殊的函数，类似于Python生成器(只是它们不生成数据——它们消耗数据)，它们用于协同多任务处理。他们可以放弃对调用者的控制，以便能够同时运行多个应用程序；</span></p>
</li>
<li>
<p><span> <strong>任务</strong></span><span>——这些用于并发调度协程。</span></p>
</li>
</ul>
<p>使用asyncio，您可以编写单线程并发代码。它是如何工作的？简而言之，子任务被定义为协程，所以您可以随意调度它们。例如，您可以将它们与事件循环同时安排。在协程产出点中，您还可以定义一些发生上下文切换的点。只有当有挂起的任务时，才会发生这种情况。如果没有，那么就没有上下文切换。</p>

<p><span>CPython的这个增强版支持</span> <span> <strong>微线程</strong> </span> <span>(称为</span> <span> <em>微线程</em> </span> <span>)的概念，允许开发者在基于线程的环境中编程，将复杂性和性能问题降到最低。</span></p>
<p><span>在无堆栈中，微线程在同一个CPU内核中处理各种子任务的完成，作为传统的基于事件的异步编码 </span> <span>的替代</span> <span> <strong>。借助通信通道、调度、任务序列化和协程支持等附加功能，程序员会发现效率显著提高，代码更加简洁，整个应用程序的结构得到了全面改善。</strong></span></p>
<p><span> <strong> 3。</strong> </span> <span> <u> <strong> <a href="http://web.archive.org/web/20220924162317/https://greenlet.readthedocs.io/">格林利特</a> </strong> </u> </span></p>
<p><span>这反过来又是一个原始的</span> <span> <strong>派生的微线程无栈</strong> </span> <span>。Greenlet是作为C扩展模块提供给Python的。它没有隐式调度功能，当您想在代码运行 </span> <span>和</span> <span> <strong>时保持</strong> </span> <span> </span> <span> <strong>控制时，以及当您的</strong></span><span/><span>工作具有相对较小的I/O时，它会非常方便有效。</span></p>
<p><span>在greenlet之上，你可以构建</span> <span> <strong>微线程</strong> </span> <span>并随意调度。但是它也可以单独使用，以便创建高级控制流结构。然而，greenlet使用Web Workers，并且只支持浏览器环境。</span></p>
<p><span> <strong> 4。</strong></span><span><u><strong><a href="http://web.archive.org/web/20220924162317/http://www.gevent.org/">Gevent</a></strong></u></span></p>
<p><span> Gevent是一个基于协程的库，它使用Greenlet来提供一个高级同步API</span><span><strong/></span><span>，一个重用来自Python标准库的事件和队列等概念的API。它的特点是建立在</span><span><u><a href="http://web.archive.org/web/20220924162317/http://software.schmorp.de/pkg/libev.html">libev</a></u></span><span>或</span><span><u><a href="http://web.archive.org/web/20220924162317/http://libuv.org/">libuv</a></u></span><span>之上的快速事件循环、轻量级和基于greenlet的执行单元、线程池以及支持SSL的协作套接字。</span></p>
<p><span> Gevent在最大限度地减少与传统线程 </span> <span>相关的开销方面</span> <span> <strong>相当强大。它可以用于数据库、web服务器和消息传递框架的并发实现。然而，它并不真正适合多核CPU程序。</strong></span></p>
<h2><span> <strong>总结</strong> </span></h2>
<p>虽然异步编码对于Python程序员来说可能不像对于JavaScript开发人员来说那么微不足道，但是仍然有一些很好的理由对异步范式产生一点兴趣。</p>
<p><span>其中一个原因是</span> <span> <strong> app性能</strong> </span> <span>。你当然不想浪费大部分时间等待任务完成。还有一个原因，与第一个紧密相连，就是</span> <a href="/web/20220924162317/https://www.netguru.com/blog/ux-tips-to-improve-website-navigation" rel=" noopener" target="_blank"> <span> <strong>用户</strong> </span> <span> </span> <span> <strong>体验</strong> </span> </a> <span>。应用程序运行得越快越流畅，用户留下来继续愉快地使用它的机会就越高。</span></p>
<p>因此，深入这个主题，看看异步编程是否是可以利用的。在某些情况下，这是完全没有必要的，但是要知道有些程序仅仅依赖于这种类型的编码。</p></span></div>    
</body>
</html>