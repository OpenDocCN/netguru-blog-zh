<html>
<head>
<title>WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>web程序集</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/webassembly#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/webassembly#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>什么是WebAssembly</p><p>“WebAssembly是一种可以在现代web浏览器中运行的新型代码，它是一种低级的类似汇编的语言，具有紧凑的二进制格式，以接近本机的性能运行，并为C/C++等语言提供编译目标，以便它们可以在web上运行。它还被设计成与JavaScript并行运行，允许两者协同工作。”- Mozilla开发者网络。</p></div><p>WebAssembly ( <strong> WASM </strong>)基本上假设所有代码都将在JavaScript沙盒运行时中以与JavaScript相同的方式执行。这意味着WebAssembly应用程序和JavaScript代码之间的内存是共享的，但是是有限的。对Web APIs的访问也受到限制，必须通过JavaScript。</p>
<p>WASM通常比Javascript快，因为它已经是二进制格式，JavaScript运行时无需解释语言就能理解。所以这意味着解码WebAssembly比解析JavaScript花费的时间要少。编译和优化也需要更少的时间，因为<strong>更接近机器码</strong>，不需要重新优化。根据功能和复杂性，WebAssembly的运行速度从10%到800%不等。</p>
<p/><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/1a.png?width=700&amp;name=1a.png 700w, http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/1a.png?width=1400&amp;name=1a.png 1400w" src="../Images/abdb67b839f7e25ae2fce0fdc2fc03f6.png" alt="Simplified client-side architecture scheme." loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/1a.png?width=700&amp;name=1a.png"/>
  </figure><p/>
<p><em>简化客户端架构方案</em></p>
<p>WebAssembly主要关注CPU密集型任务，可成功用于:</p>
<ul>
<li>
<p>比赛</p>
</li>
<li>
<p>图像、视频、音频或CAD流和编辑</p>
</li>
<li>
<p>虚拟现实和增强现实</p>
</li>
<li>
<p>仿真或模拟平台</p>
</li>
<li>
<p>加密</p>
</li>
<li>
<p>人工智能</p>
</li>
<li>
<p>P2P应用</p>
</li>
<li>
<p>VPN和远程桌面</p>
</li>
<li>
<p>物联网</p>
</li>
<li>
<p>机器学习</p>
</li>
</ul>
<h2><strong>构建到web程序集</strong></h2>
<p>非常重要的是，WebAssembly在所有主流浏览器中都得到支持:Mozilla Firefox、Google Chrome、Safari和Edge，这是实现其假设所必需的，比如可移植性。主要目标是在几乎任何地方运行WASM，从浏览器到服务器端以及嵌入式系统。WebAssembly的目标与Java试图通过小程序实现的目标相同。</p>
<p>因为WASM旨在成为C、C++、Rust等低级源语言的有效编译目标，所以使用这些语言之一来创建WebAssembly模块是一个自然的选择。为什么能成为一个好的选择？因为在这些语言中我们是手动管理内存的，而当前版本的WebAssembly根本不支持垃圾回收。</p>
<p>然而，这并不意味着我们不能使用其他使用该功能的编程语言，如Python、Go或C#。这将要求我们使用额外的工具或解释器来实现特定语言的功能。</p>
<p> </p>
<p>WebAssembly支持的语言<strong> <em>(需要第三方工具或翻译):</em> </strong></p>
<ul>
<li>
<p><strong>T1。网</strong></p>
</li>
<li>
<p><strong> <em>汇编脚本</em> </strong></p>
</li>
<li>
<p>C</p>
</li>
<li>
<p><em><strong/>c#</em></p>
</li>
<li>
<p>C++</p>
</li>
<li>
<p><em> <strong> D </strong> </em></p>
</li>
<li>
<p>向外</p>
</li>
<li>
<p><strong> <em>走</em> </strong></p>
</li>
<li>
<p><strong> <em> Java </em> </strong></p>
</li>
<li>
<p><strong> <em>伊德里斯</em>T3】</strong></p>
</li>
<li>
<p><strong> <em>科特林/本土</em>T3】</strong></p>
</li>
<li>
<p>左上臂</p>
</li>
<li>
<p><em> <strong> Perl </strong> </em></p>
</li>
<li>
<p><em> <strong> PHP </strong> </em></p>
</li>
<li>
<p><em> <strong>诗歌</strong> </em></p>
</li>
<li>
<p><em> <strong> Python </strong> </em></p>
</li>
<li>
<p><em> <strong>序言</strong> </em></p>
</li>
<li>
<p><em> <strong>红宝石</strong>T3】</em></p>
</li>
<li>
<p>锈</p>
</li>
<li>
<p><em> <strong>方案</strong> </em></p>
</li>
<li>
<p><em> <strong>哇</strong> </em></p>
</li>
<li>
<p><em> <strong>沃尔特</strong>T3】</em></p>
</li>
<li>
<p><em><strong>Wam</strong>T3】</em></p>
</li>
</ul>
<p>WebAssembly由两种表示相同结构的格式组成，但方式不同:</p>
<p><strong>实施例</strong></p>

<h2>举个例子，假设我们在Rust中创建了一个简单的square函数，我们将在JavaScript中使用它在容器中显示结果。我们假设WASM编译是成功的，并且我们收到了一个准备好的文件，可以作为模块导入。</h2>
<p>我们的函数看起来像这样:</p>
<p>此时，我们要做的就是创建一个JavaScript文件，并使用<strong> fetch() </strong>和<strong>WebAssembly . instantiate()</strong>来获取、编译和实例化web assembly代码。这样，我们就可以访问我们的<strong>广场</strong>功能。代码如下所示:</p>
<p>Our function looks like this:</p>
<p><strong>现实世界应用</strong></p><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image5-10.png?width=700&amp;name=image5-10.png 700w, http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image5-10.png?width=1984&amp;name=image5-10.png 1984w" src="../Images/635a82c308138030e9284f453d8e1dbb.png" alt="Example function" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image5-10.png?width=700&amp;name=image5-10.png"/>
  </figure>and after compilation, we get this:<p>如何完美地使用WebAssembly的最好例子是<strong> AutoCAD </strong>。在几次尝试其旗舰产品的网络应用程序后，<strong> Autodesk </strong>决定使用WASM。现在是紧挨着<strong> React.js </strong> (UI层)的应用层之一。之前，他们尝试了Adobe Flash和HTML5与JavaScript。有趣的事实是，在将代码库编译为WebAssembly之前，他们必须删除Windows API的所有依赖项。</p>
<p/><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image6-8.png?width=700&amp;name=image6-8.png 700w, http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image6-8.png?width=1400&amp;name=image6-8.png 1400w" src="../Images/6e7397e34d37af0ec8df130604b33e4c.png" alt="Code after compilation" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image6-8.png?width=700&amp;name=image6-8.png"/>
  </figure>Now we can prepare the basic HTML structure in our index.html <figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image2-17.png?width=700&amp;name=image2-17.png 700w, http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image2-17.png?width=1780&amp;name=image2-17.png 1780w" src="../Images/4277e90ca6cb8af737183ba41301fdc7.png" alt="HTML code" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image2-17.png?width=700&amp;name=image2-17.png"/>
  </figure><p/>
<p>WebAssembly提供的可能性的另一个例子是允许你开发游戏的<strong> Construct 3 </strong>和设计者的工具<strong> Figma </strong>。还值得一提的是<strong>PSP PDF kit</strong>-一款生成PDF文档的应用程序和<strong> ACTIV Financial </strong> -实时和多资产金融市场数据和解决方案提供商。</p><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image1-26.png?width=700&amp;name=image1-26.png 700w, http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image1-26.png?width=1400&amp;name=image1-26.png 1400w" src="../Images/f94c01bc60c09817e24beba308f934f7.png" alt="JS code" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image1-26.png?width=700&amp;name=image1-26.png"/>
  </figure><p><strong>含义</strong></p>
<h2>当前版本的WebAssembly中缺少的一个部分是，它们不能直接访问像DOM、CSSOM、WebGL、IndexedDB、Web Audio API等Web APIs。所以如果你想在你的WebAssembly模块中访问一些特定于平台的API，你需要用JavaScript调用它。当然，这样的操作对于那些JavaScript调用来说是一种代价。</h2>
<p>与JavaScript一样，WebAssembly运行在沙盒执行环境中，这意味着它将强制执行浏览器的同源权限策略，并且也不能访问文件系统。</p>
<p>一个相当大的不便是浏览器调试器支持还没有真正实现。</p><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image7-5.png?width=700&amp;name=image7-5.png 700w, http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image7-5.png?width=1400&amp;name=image7-5.png 1400w" src="../Images/7111faeefefa43c8be4084fa4585751f.png" alt="Simplified AutoCAD application layers" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/image7-5.png?width=700&amp;name=image7-5.png"/>
  </figure><em>Simplified AutoCAD application layers.</em> <p> </p>
<p><strong>局限性</strong> <em> <strong>(缺失部分)</strong> </em> <strong> : </strong></p>
<h2>多线程操作</h2>
<p>单指令多数据(SIMD)</p>
<p>碎片帐集</p>
<p>ES模块集成</p>
<p>异常处理</p>
<p>JavaScript和WASM之间的快速交互和数据交换</p>
<ul>
<li>
<p>Wasm64(支持wasm32模式，线性内存大小高达4 GiB)</p>
</li>
<li>
<p>多值回报</p>
</li>
<li>
<p>BigInt转换</p>
</li>
<li>
<p><strong>前端开发者视角</strong></p>
</li>
<li>
<p>那么，WebAssembly是不是属于<a href="/web/20220929114645/https://www.netguru.com/services/front-end-development" rel="noopener">前端开发者</a>的技术？在我看来，并不是。当然，我们将使用它，但是基于API通信。WASM是一种技术，它肯定会给后端开发人员更多空间来提高性能，<a href="/web/20220929114645/https://www.netguru.com/services/web-development" rel="noopener">开发可扩展的web应用程序</a>。WebAssembly和其他两种web技术的潜在用途看起来非常有趣，对我来说，它们是完美的互补。</p>
</li>
<li>
<p>第一个组合是WASM与<a href="/web/20220929114645/https://www.netguru.com/services/progressive-web-app-development" rel="noopener"> <strong>渐进式网络应用</strong> </a> (PWA)。这是一个非常明显的组合，考虑到PWA为常规网站和web应用程序(例如离线工作)提供类似于本机应用程序的用户功能。</p>
</li>
<li>
<p>第二个是拥有<strong> Web组件</strong>的WASM。这两种技术的结合为开发人员提供了创建高级HTML组件的机会。举个简单的例子，我们将能够开发一个内置编解码器的视频播放器组件。当然，这个解决方案提供了各种各样的可能性，像任何文件类型查看器甚至编辑器。</p>
</li>
<li>
<p><strong>总结</strong></p>
</li>
<li>
<p>WebAssembly最重要的优势之一是，它允许开发人员创建在质量和性能上与本机桌面应用程序没有区别的web应用程序。与传统应用程序相比，开发和维护软件本身的成本会更低。这是因为应用程序的分发仅限于浏览器，同时覆盖所有可能的操作系统。此外，将桌面应用程序转换为web应用程序的成本应该不会很高，因为我们可以使用现有的代码，并将其重新编译为WebAssembly，最完美的例子是Autodesk。</p>
</li>
</ul>
<h2>但是，应该记住，WebAssembly是一项相对较新的技术，它的局限性肯定会使我们很难决定它的潜在用途。</h2>
<p><strong>建议</strong></p>
<p>WebAssembly的开发和后续迭代应该<strong>明确</strong>被<strong>观察</strong>。然而，我认为在目前的项目中使用它的可能性可能是一个普通的<strong>矫枉过正</strong>。根据我的评估，WebAssembly的使用只有在严格定义的情况下才有意义，主要是<strong>大型</strong>规模<strong>应用</strong>。</p>
<p><strong>附录</strong></p>
<h2><strong> Webassembly工作室</strong></h2>
<p>是Mozilla开发的一个在线IDE，可以用来编译C/C++和Rust代码到WebAssembly中。</p>
<p><a href="http://web.archive.org/web/20220929114645/https://webassembly.studio/">https://webassembly.studio/</a></p>
<h2><strong> Emscripten </strong></h2>
<p>是JavaScript和WebAssembly编译器的开源LLVM。让开发人员能够编译用/ C ++编写的项目，还内置了OpenGL到WebGL的转换，并允许我们直接使用熟悉的API，如SDL或HTML5。</p>
<h2><strong> asm.js </strong></h2>
<h3>是JavaScript的一个非常优化的低级子集，设计用于在浏览器中运行C/C++代码，这些代码以前由编译器翻译，如<strong> Emscripten </strong>。这个解决方案正慢慢被WASM取代。然而，在WebAssembly的当前阶段，它在某些功能上受到限制，例如，在浏览器中调试代码，asm.js可以提供帮助。</h3>
<p>布拉索</p>
<p>是一个基于C#、Razor、Mono和HTML的. NET web框架，通过WebAssembly在web浏览器中运行。开发人员可以用C#或VisualBasic.NET编写代码，然后编译成普通代码。NET程序集。代码将在使用基于WebAssembly的web浏览器中运行。NET运行时。</p>
<h3><strong>Emscripten</strong></h3>
<p>Is an Open Source LLVM to JavaScript and WebAssembly compiler. Gives the developer the ability to compile projects written in / C ++, also has a built-in conversion OpenGL into WebGL, and allows us to use familiar APIs like SDL, or HTML5 directly.</p>
<h3><em>简化客户端架构方案</em></h3>
<p><strong>参考文献</strong></p>
<h3><a href="http://web.archive.org/web/20220929114645/https://docs.google.com/spreadsheets/d/1gl6PxELXtTQubJsIQh4VFwFMEFn9IDYgOcC3kOf2jLE/edit#gid=0" rel="noopener">R&amp;D-web assembly-Articles</a></h3>
<p><span>照片由<span> </span> </span> <a href="http://web.archive.org/web/20220929114645/https://unsplash.com/photos/HUJDz6CJEaM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">克里斯·利维拉尼</a> <span> <span> </span>上<span> </span> </span> <a href="http://web.archive.org/web/20220929114645/https://unsplash.com/search/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">下</a></p>
<p/><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/2b.png?width=700&amp;name=2b.png 700w, http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/2b.png?width=1400&amp;name=2b.png 1400w" src="../Images/8e719f7f53a815dbd8e7868cc4e3a3ed.png" alt="Simplified client-side architecture scheme" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20220929114645im_/https://www.netguru.com/hs-fs/hubfs/2b.png?width=700&amp;name=2b.png"/>
  </figure><p/>
<p><em>Simplified client-side architecture scheme</em></p>
<h2><strong>References</strong></h2>
<p><a href="http://web.archive.org/web/20220929114645/https://docs.google.com/spreadsheets/d/1gl6PxELXtTQubJsIQh4VFwFMEFn9IDYgOcC3kOf2jLE/edit#gid=0" rel="noopener">R&amp;D - WebAssembly - Articles</a></p>
<hr/>
<p><span>Photo by<span> </span></span><a href="http://web.archive.org/web/20220929114645/https://unsplash.com/photos/HUJDz6CJEaM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Chris Liverani</a><span><span> </span>on<span> </span></span><a href="http://web.archive.org/web/20220929114645/https://unsplash.com/search/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p></span></div>    
</body>
</html>