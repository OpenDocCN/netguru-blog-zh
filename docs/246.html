<html>
<head>
<title>Data Down Action... Down in Emberjs - Using Ember.Evented</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>数据下降动作...在Emberjs -使用Ember。事件</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/data-down-action-in-emberjs#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/data-down-action-in-emberjs#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>如果你已经使用Ember有一段时间了，这篇文章的主题对你来说就像异端邪说。数据下行动作下行？不会吧！另一方面，如果你不熟悉这个概念，你可能想知道这四个词是什么意思。</p></div><p/>
<p>数据向下操作向上(DDAU)是今年<a href="http://web.archive.org/web/20221007200007/https://www.netguru.com/services/vue-js-development">月</a>的一个最佳实践概念。它假设您的数据从上(数据的所有者，如路由)流向下(数据的呈现者，如组件)。另一方面，<strong>动作改变来自这些动作的接收者的数据流，从用户</strong>(像组件的按钮)到负责执行它们的所有者(像路由)。这种架构应该有助于您维护代码和应用程序。我是DDAU的忠实粉丝和支持者，但我也遇到过它不适用的边缘案例。</p>
<p>那么，为什么要以不同的方式设计数据流呢？基本上，有时动作不是由用户直接在组件上触发的。假设我们有一个可以通过键盘控制的待办事项列表。用户可以在列表中上下移动，并通过单击Enter扩展描述。我们希望它独立于当前有焦点的DOM元素来控制。所以我们使用一些插件，在控制器层面上神奇地拦截键盘事件(具体如何并不重要)。要查看大图，看看这个<a href="http://web.archive.org/web/20221007200007/https://ember-twiddle.com/dc85ac9d49e49c5663a1?numColumns=1&amp;openFiles=twiddle.json%2C" rel="nofollow" target="_blank">余烬旋转</a>，它在底部模拟了上/下/回车键。那么，当直接接收到控制器时，我们如何在当前活动的组件上触发一个动作呢？</p>
<p>这是我们可以利用数据下降、行动下降的地方。</p>
<h2>可组合组件</h2>
<p>每次我在写或谈论组件和数据流时，我都忍不住要提到Miguel Camba的一个非常好的演示，叫做T2的可组合组件。简单总结一下这个想法——Miguel设法通过产生组件的公共API来提供一种恢复动作流的极好方法。<strong>这让你可以通过处理公共API来使用它，例如在另一个组件中，在yielding one </strong>中呈现:</p>
<p data-gist-id="7a00f7e42dde12947e5f"> </p>
<p data-gist-id="229d40b0a9b98dc34431"> </p>
<p>不幸的是，这种用法有限。它不能用在我们的用例中。尽管它很聪明，但它只利用了JavaScript闭包，而真正的动作执行者是屈服组件中的DOM元素。我们希望在不构建任何会指出最终接收者的闭包的情况下处理事件。</p>
<h2>烬。事件</h2>
<p>什么是<a href="http://web.archive.org/web/20221007200007/http://emberjs.com/api/classes/Ember.Evented.html" rel="nofollow" target="_blank">灰烬。事件</a>？你听说过吗？这是一个可以在任何你想要的Ember对象中使用的mixin。它提供了一个非常简单但功能强大的API来触发和接收浏览器文档中的事件。</p>
<p>Ember的最佳用例是什么？事件？创建一个混合在Ember.Evented中的Ember服务。然后，我们可以使用它作为任何我们希望能够与之通信的对象之间的代理。在我们的例子中，<strong>我们将把服务注入到一个控制器中，当按键发生时</strong>触发控制器上的事件。另一方面，我们将在每个应该对这些事件执行某些操作的组件中监听这些事件。这种简单的模式允许您在由于父子关系而无法轻松通信的对象之间进行通信。<a href="http://web.archive.org/web/20221007200007/https://ember-twiddle.com/dc85ac9d49e49c5663a1?numColumns=3&amp;openFiles=application.controller.js%2Ctodos-list.component.js%2Ckeyboard-dispatcher.service.js" rel="nofollow" target="_blank">在这里你可以查看服务、组件和控制器的完整代码</a>。下面你可以看到一小段:</p>
<p data-gist-id="d25f5479fff0be6f2fdd"> </p>
<p data-gist-id="1d08432adf2ddef55cbc"> </p>
<p>其背后的逻辑相当明显。基本上，我们在运行<code>on</code>时所做的就是将方法添加到存储所有监听器的元对象中。当触发事件时，它遍历侦听器数组，并直接从元对象开始以相反的顺序执行每个函数。简单，但功能强大。</p>
<h2>摘要</h2>
<p>数据向下操作向下不是我们应该经常使用的模式，因为它会给我们的应用程序带来难以预料的后果。<strong>当我们忘记通过在对象</strong> destroy上运行<code>off</code>来删除监听器时，也很容易引入内存泄漏。烬。Evented更适合边缘情况的解决方案。意识到这些可能性并理解它们是如何工作的是很有用的。</p>
<p>你用过Ember吗？在你的工作中发生了什么？你碰到过这种模式的一些问题吗？滴个评论，分享一下经验吧！</p>
<p>如果你对Ember.js隐藏的机会和陷阱感兴趣，请查看我的关于Ember Run Loop的电子书。</p></span></div>    
</body>
</html>