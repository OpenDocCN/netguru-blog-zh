<html>
<head>
<title>What ActiveModel::Serializers Can Do for Ember Data API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>active model::serializer能为Ember数据API做什么</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/active-model-serializers-ember#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/active-model-serializers-ember#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h2"><p>我曾有机会编写一个在后端模型之间具有深度嵌套关系的应用程序，在这篇文章中，我将给出一些例子来说明为什么JSON API是这样一个应用程序的最佳选择。</p></div><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221007094001im_/https://www.netguru.com/hubfs/images/posts/1443528929-serializers.jpg 0w" src="../Images/abedba4f38c669faec70ccb92c6f3212.png" alt="" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221007094001im_/https://www.netguru.com/hubfs/images/posts/1443528929-serializers.jpg"/>
  </figure><p/>
<p>我使用Ember已经快一年了。我喜欢约定胜于配置的方法——它使得探索一起使用Ember和Rails所创造的可能性变得容易。我曾有机会编写一个在后端模型之间具有深度嵌套关系的应用程序，在这篇文章中，我将给出一些例子来说明为什么JSON API是这样一个应用程序的最佳选择。JSON API是一个相当新的标准，但是我有使用ActiveModelAdapter和JSON API的经验，不能过分强调<strong> JSON API更容易使用</strong>。</p>
<h3>侧面装载与非侧面装载</h3>
<p>首先，你应该考虑一下你的人际关系。侧装是什么意思？假设您有两个带序列化程序的模型，如下所示:</p>
<p class="legacy-code-gist" data-gist-id="f92fd64275b6e90ee3e5"> </p>
<p>没有侧面加载(或者说，包括)的示例JSON响应<strong>在用户控制器中将是这样的:</strong></p>
<p class="legacy-code-gist" data-gist-id="23cc9d97df7a96866ed1">有效载荷如下:</p>
<p>Ember数据序列化器将把它反序列化到一个<code>User</code>记录中，如果需要的话，可以自动获取相关的注释(例如，在模板<code/>中显式获取)。然而，这意味着对每个笔记向API发出一个请求，如果您有一个很大的列表，这会非常麻烦。因此，我们可以让我们的序列化程序使用侧加载，并修改控制器如下:</p>
<p class="legacy-code-gist" data-gist-id="810a4bba55df634e41b0"> </p>
<p>这样，我们可以将这些对象包含在一个响应负载中。Ember data会注意到有效负载包含其他模型的附加散列，并将自动为发送的记录创建实例。例如:</p>
<p class="legacy-code-gist" data-gist-id="16d6c114c652b2dddbbc"> </p>
<p>这样，我们可以减少对API的请求数量，并改善用户体验。你甚至可以包含像<code>includes: %w(notes notes.comments)</code>这样的嵌套关系。在没有JSON API的情况下使用Active Model Serializers 0.8时，这是不可能的——所有包含都是在serializer中定义的，当每个端点都有不同的序列化程序时，这是一个维护噩梦。</p>
<p class="legacy-code-gist" data-gist-id="b70d5f33f60ea12c8fd2">此外，JSON API为每个关系处理<code>type</code>键。由于这一点，您不必担心您的名为<code>friends</code>，但地址为<code>users</code> ( <code>has_many :friends, class: ‘User’, foreign_key: ‘user_id’</code>)的关系是否会被适当地反序列化为Ember中的<code>friends</code>关系。最后，但同样重要的是，多态和非多态关系之间基本上没有区别——两者都存储<code>type</code>键。</p>
<p>然而，序列化器用一种<code>each</code>方法遍历对象的关系。确保使用<code>ActiveRecord</code>、<code>include</code>或<code>eager_load</code>方法正确地包含关系。没有它，您将会以冗长的N+1查询结束。然而，没有解决这些问题的灵丹妙药，不愉快的情况将不可避免地出现。</p>
<p>处理深层嵌套关系</p>
<p>假设您的应用程序中有一个更有趣的场景。在你的应用程序中有几十个模型并不罕见，所有模型都通过关系连接在一起。假设您有一家公司，该公司有许多请求，这些请求有订单、注释、客户等。——几十条(甚至几百条)记录。即使使用某种AJAX分页，获取几个包含嵌套很深的数据的请求也会让用户等待，从而严重影响用户体验。</p>
<h3>另一方面，实际上很少一次需要所有这些数据——您可能只需要一个请求中的订单数或属于该请求的客户名称—<strong>而不是</strong>深层嵌套的相关对象。为了提高性能，您可以创建两种(或更多)类型的序列化程序——基本序列化程序和“侧面加载序列化程序”。在您的<code>show</code>端点中，您使用完整的端点，(侧面加载完整的关系可能是值得的)，但是在<code>index</code>端点中，您可以使用瘦端点。</h3>
<p>假设您有如下关系:</p>
<p>On the other hand, it's very rare to actually need all of this data at once - you likely only need the count of orders in one request or just a customer name that belongs to that request - <strong>not</strong> the deeply nested related objects. To improve performance, you can create two (or more) types of serializers - the base one and the "side-loaded one". In your <code>show</code> endpoints you use full ones, (it’s probably worth it to have sideloaded the full relationships), but in <code>index</code> endpoints you can use the thin ones.</p>
<p>Let’s say you have relationships as follows:</p>
<p class="text-"> </p><figure class="image&#10;    &#10;    image--framed&#10;    " data-image="" data-component="image">
    <img class="image__content" srcset="http://web.archive.org/web/20221007094001im_/https://www.netguru.com/hs-fs/hub/493098/file-3517017383-png/blog-files/1443522241-1443522238-image00.png 0w" src="../Images/79f289cf2e005dc4f77a2eb12d53d2c4.png" alt="" loading="lazy" data-image-content="" data-original-src="http://web.archive.org/web/20221007094001im_/https://www.netguru.com/hs-fs/hub/493098/file-3517017383-png/blog-files/1443522241-1443522238-image00.png"/>
  </figure><p>在你的<code>Request index view</code>中，你根本不需要那些<code>LineItem</code> s，所以不要序列化它们:</p>
<p class="cc text-"> </p>
<p>这样，输入您的<code>Requests</code>索引路由将只为深层关系的第一级等待请求有效负载侧加载，而不会进行任何额外的数据库查询来获取每个订单行项目的id。另一方面，这种解决方案最终会导致缓存的模型没有侧面加载的记录。如果您从上面的例子中输入<code>order</code> route，那么您的模型钩子可能在没有侧载关系的情况下解析，这是错误的，因为它们存在但没有被提取。在ember-data中最近的变化之后，如果您需要使用<code>store.findRecord</code>在您的模型钩子中获取侧面加载的订单记录，它将立即使用缓存的瘦订单(从侧面加载)进行解析。</p>
<p class="legacy-code-gist" data-gist-id="5f9109eca921f1aa7990">在后台，ember-data将点击您的<code>orders</code>端点以获取最新数据，如果您使用侧加载的<code>lineItems</code>关系进行响应，它将最终被重新呈现。您还可以显式地让ember-data从端点重新加载模型，而无需立即解析，从而确保在您的控制器中，您将同时拥有订单及其行项目，只需一个简单的<code>reload</code>参数:</p>
<p> </p>
<p>看看<a href="http://web.archive.org/web/20221007094001/http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html">这篇关于ember-data 1.13版本</a>的博文。</p>
<p class="legacy-code-gist" data-gist-id="5a538c30e942fd2737d6">摘要</p>
<p>在本文中，我试图向您展示当您遵循JSON API提供的约定和标准时，使用Rails API是多么容易。我从0.8版本(不支持JSON API)开始就一直使用默认的ActiveModelSerializers适配器，我认为它现在更加容易和灵活。不要忘记在每个端点中显式地加载单个模型的可能性。以前没这么容易！</p>
<h3>有了这些知识，您就可以构建非常复杂的应用程序，同时在易维护性和性能之间保持平衡。然而，我很确定你已经遇到过(或者会发现)更复杂的例子。你愿意和我们分享吗？我们很想在评论中听到他们的消息！</h3>
<p>In this post, I tried to show you how easy it can be to work with Rails API when you adhere to the conventions and standards provided by JSON API. I have been working with default ActiveModelSerializers adapters since version 0.8 (which didn’t support JSON API) and I think that it’s currently much easier and flexible. Don’t forget about the possibility of explicitly sideloading individual models in each endpoint. It was not so easy before!</p>
<p>With this knowledge, you can build very complex applications while still having a balance between ease of maintenance and performance. However, I am pretty sure that you’ve come across (or will find) more complex examples. Would you care to share them with us? We’d love to hear about them in the comments!</p></span></div>    
</body>
</html>