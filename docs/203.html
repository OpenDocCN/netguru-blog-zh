<html>
<head>
<title>Networking with RxSwift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>与RxSwift联网</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/networking-with-rxswift#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/networking-with-rxswift#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>如今，几乎每个应用程序都有某种服务器连接。在这个初学者的小教程中，我将向你展示如何使用RxSwift处理网络通信。出于本指南的目的，我们将创建一个使用<a href="http://web.archive.org/web/20220924170412/http://universities.hipolabs.com/"> Hipolabs API </a>搜索大学的小应用程序。网络通信的核心将基于<code>URLSession</code>。我假设你知道iOS编程的基础，所以我将只着重解释项目的Rx部分。</p></div><h2 id="prepare-project">准备项目</h2>

<p>我们旅程的第一步是准备项目，在Xcode中创建项目后，我们需要添加两个外部库:</p>

<p>我使用了那个<a href="http://web.archive.org/web/20220924170412/https://cocoapods.org/"> Cocoapods </a>，但是可以通过<a href="http://web.archive.org/web/20220924170412/https://github.com/Carthage/Carthage"> Carthage </a>或者手动随意导入库。有关说明，请访问<a href="http://web.archive.org/web/20220924170412/https://github.com/ReactiveX/RxSwift#installation"> RxSwift知识库页面</a></p>
<h3 id="simple-layout">简单布局</h3>
<p>当我们的项目为编码做好准备时，我们需要创建一个显示接收数据的地方。为此，我在主<code>ViewController</code>中创建了简单的<code>UITableView</code>和<code>UISearchController</code>，它们应该嵌入到<code>UINavigationController</code>中</p>
<p>下面是完成这项工作的代码:</p>
<pre><code class="language-swift">private let tableView = UITableView()
private let cellIdentifier = "cellIdentifier"

private let searchController: UISearchController = {
  let searchController = UISearchController(searchResultsController: nil)
  searchController.searchBar.placeholder = "Search for university"
  return searchController
}()

private func configureProperties() {
    tableView.register(TableViewCell.self, forCellReuseIdentifier: cellIdentifier)
    navigationItem.searchController = searchController
    navigationItem.title = "University finder"
    navigationItem.hidesSearchBarWhenScrolling = false
    navigationController?.navigationBar.prefersLargeTitles = true
}

private func configureLayout() {
    tableView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(tableView)
    NSLayoutConstraint.activate([
        tableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
        tableView.leftAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leftAnchor),
        tableView.rightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.rightAnchor),
        tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
    ])
    tableView.contentInset.bottom = view.safeAreaInsets.bottom
}</code></pre>
<p>这是结果:</p>

<h2 id="what-we-want-to-receive-how-we-want-to-receive-it">我们想要得到什么？我们希望如何接受它？</h2>
<p>如果我们的布局准备好了，我们可以尝试处理来自REST API的一些数据。为此我们将使用<a href="http://web.archive.org/web/20220924170412/http://universities.hipolabs.com/"> Hipolabs API </a>。我们想从我们的<code>UISearchController</code>中获得包含搜索短语的大学信息。</p>
<h3 id="example">例子</h3>
<p>这里有一个用<code>middle</code>作为名称参数查找大学的请求和响应的例子。</p>
<table>
<thead>

</thead>
<tbody>
<tr class="odd">
<td align="center"><code>http://universities.hipolabs.com/search?name=middle</code></td>
</tr>
<tr>
<td><strong>响应</strong></td>
</tr>
<tr>
<td><code>[{"name": "Middlesex University", "domains": ["mdx.ac.uk"], "web_pages": ["http://www.mdx.ac.uk/"], "alpha_two_code": "GB", "state-province": null, "country": "United Kingdom"}, ...]</code></td>
</tr>
</tbody>
</table>
<p> </p>
<p>现在，当我们知道API如何工作时，我们就可以创建请求和模型对象了。</p>
<h3 id="model">模型</h3>
<p>对于来自服务器的数据，我们可以使用类似于<code>[String: Any]</code>的JSON字典，但我更喜欢创建更清晰、更易于使用的数据模型。为了接收大学对象，我创建了struct <code>UniversityModel</code>，它符合<code>Codable</code>协议，因此我们不需要为解析数据而烦恼，让我们把它留给swift引擎吧。</p>
<pre><code class="language-swift">struct UniversityModel: Codable {
    let name: String
    let webPages: [String]?
    let country: String

    private enum CodingKeys: String, CodingKey {
        case name
        case webPages = "web_pages"
        case country
    }
}</code></pre>
<h3 id="requests">要求</h3>
<p>为了使这更通用，我们需要创建<code>APIRequest</code>协议，这样不同的请求可以由同一个<code>APIClient</code>来处理。</p>
<p><code>APIRequest</code>类由两部分组成:</p>
<p>协议本身，其中定义了必要的属性:</p>
<pre><code class="language-swift">protocol APIRequest {
    var method: RequestType { get }
    var path: String { get }
    var parameters: [String : String] { get }
}</code></pre>
<p>将从<code>APIRequest</code>的实例创建<code>URLRequest</code>的协议扩展:</p>
<pre><code class="language-swift">extension APIRequest {
    func request(with baseURL: URL) -&gt; URLRequest {
        guard var components = URLComponents(url: baseURL.appendingPathComponent(path), resolvingAgainstBaseURL: false) else {
            fatalError("Unable to create URL components")
        }

        components.queryItems = parameters.map {
            URLQueryItem(name: String($0), value: String($1))
        }

        guard let url = components.url else {
            fatalError("Could not get url")
        }

        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        request.addValue("application/json", forHTTPHeaderField: "Accept")
        return request
    }
}</code></pre>
<p>我还在<code>APIRequest</code>类中创建了一个小枚举来改进httpMethod的声明:</p>
<pre><code class="language-swift">public enum RequestType: String {
    case GET, POST
}</code></pre>
<p>当协议准备好了，我们就可以提出真正的请求，通过名字来搜索大学。为此，我们需要创建另一个从<code>APIRequest</code>协议继承的类，其中定义了方法、端点路径和参数。</p>
<pre><code class="language-swift">class UniversityRequest: APIRequest {
    var method = RequestType.GET
    var path = "search"
    var parameters = [String: String]()

    init(name: String) {
        parameters["name"] = name
    }
}</code></pre>
<p>好吧，有很多，但是这个RxSwift在哪里？</p>
<h2 id="time-for-magic">魔法时间到</h2>

<p>现在是拼图中最重要的一块的时候了，这部分将改变我们对服务器数据的请求。现在是<code>APIClient</code>的时候了！</p>
<p><code>APIClient</code>是一个类，我们将从RxCocoa使用<code>URLSession</code>上的<code>rx</code>扩展发出请求，然后<code>map</code>将响应数据发送到已经解析的数据模型(如果只有模型是<code>Codable</code>)。<code>.data(request: URLRequest)</code>函数将确保我们的状态代码是<code>200..&lt;300</code>，然后返回数据，如果不是，那么它将抛出一个错误。</p>
<pre><code class="language-swift">class APIClient {
    private let baseURL = URL(string: "http://universities.hipolabs.com/")!

    func send&lt;T: Codable&gt;(apiRequest: APIRequest) -&gt; Observable&lt;T&gt; {
        let request = apiRequest.request(with: baseURL)
        return URLSession.shared.rx.data(request: request)
            .map { 
                try JSONDecoder().decode(T.self, from: data)
            }
            .observeOn(MainScheduler.asyncInstance)
    }
}</code></pre>
<h2 id="one-more-last-thing...">还有一件事...</h2>
<p>创建完<code>APIClient</code>后，最后一部分是将所有东西连接在一起。</p>
<p>我们期望的结果:</p>
<p><strong>在搜索字段中键入搜索短语</strong> → <strong>用搜索短语</strong> → <strong>创建的请求实例大学模型数组</strong> → <strong>刷新<code>UITableView</code>用新数据</strong>填充，所有这些都在<strong>的10行中！！！</strong></p>
<pre><code class="language-swift">searchController.searchBar.rx.text.asObservable()
  .map { ($0 ?? "").lowercased() }
  .map { UniversityRequest(name: $0) }
  .flatMapLatest { [unowned self] request -&gt; Observable&lt;[UniversityModel]&gt; in
    return self.apiClient.send(apiRequest: request)
  }
  .bind(to: tableView.rx.items(cellIdentifier: cellIdentifier)) { index, model, cell in
    cell.textLabel?.text = model.name
  }
  .disposed(by: disposeBag)</code></pre>

<p>请记住导入<code>RxSwift</code>和<code>RxCocoa</code>并创建两个变量:</p>
<pre><code class="language-swift">private let apiClient = APIClient()
private let disposeBag = DisposeBag()</code></pre>


<p>如果你想在用户点击单元格时呈现一个大学网站，你可以通过利用模型和反应式绑定，用7行代码来实现。</p>
<pre><code class="language-swift">tableView.rx.modelSelected(UniversityModel.self)<br/>  .map { URL(string: $0.webPages?.first ?? "")! }
  .compactMap { URL(string: $0) }
  .map { SFSafariViewController(url: $0) }
  .subscribe(onNext: { [weak self] safariViewController in
    self?.present(safariViewController, animated: true)
  })
  .disposed(by: disposeBag)</code></pre>
<h2 id="final-effect"><strong>最终效果</strong></h2>

<p>今天到此为止。你可以在这个<a href="http://web.archive.org/web/20220924170412/https://github.com/saoth/Networking-with-RxSwift" rel="noopener">库</a>找到整个项目。我希望你喜欢。</p></span></div>    
</body>
</html>