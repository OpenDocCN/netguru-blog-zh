# Python 基础:列表理解、字典理解和生成器表达式

> 原文：<http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/python-list-comprehension-dictionary>

 Python 相对于其他编程语言的主要优势之一是它简洁、可读的代码。但是，即使在 Python 语言本身中，也有一些方法可以编写更优雅的代码，并更有效地获得相同的最终结果。

列表理解、字典理解和生成器表达式是这种优雅表达式的三个强有力的例子。在这篇文章中，我们将看看 for 循环、列表理解、字典理解和生成器表达式，以展示它们如何节省您的时间并使 Python 开发更容易。

## Python 中的列表和字典理解

为了理解列表和字典理解的基础，让我们先来看一下循环的*。*

### *for-* 循环

在 Python 中， *for-* 循环非常适合处理重复的编程任务，因为它可以用来迭代序列，比如列表、字典或字符串。

让我们看一个使用列表的简单例子:

```
*words = ['cat', 'window', 'ball']*

*for x in words:*

 *print(x)*
```

结果是每个元素一个接一个地打印在单独的行中:

```
*cat*

*window*

*ball*
```

当你开始掌握更复杂的循环的*，并随后列出理解和字典理解时，理解它们背后的逻辑是有用的。*

循环的*通过获取 iterable 的第一个元素(在上面的例子中是一个列表)并检查它是否存在来工作。如果是，则执行所需的动作(在上述情况下，*打印*)。然后循环再次开始，寻找下一个元素。如果该元素存在，则再次执行所需的操作。重复这种行为，直到没有找到更多的元素，循环结束。*

### 使用 range()函数

非常有用的 range()函数是一个内置的 Python 函数，几乎专门与*一起用于*循环。本质上，它的目的是生成一个数字序列。

让我们看一个例子来了解它是如何工作的:

```
*for i in range(5):*

 *print(i)*
```

结果是:

```
*0*

*1*

*2*

*3*

*4*
```

请注意，range()函数从 0 开始，因此 range(5)将返回数字 0 到 4，而不是 1 到 5。

默认情况下，序列将从 0 开始，以 1 为步长递增，并在指定的数字处结束。然而，可以将第一个元素、最后一个元素和步长定义为*范围*(第一个、最后一个、步长)。

### 列出理解

List comprehensions 为循环提供了一种比*更紧凑、更优雅的方式来创建列表，并且还允许您从现有列表中创建列表。*

列表理解由包含一个表达式的括号构成，该表达式后跟一个 for 子句，即*[item-item for item in iterator]*或 *[x for x in iterator]* ，如果子句:*[item-item for item if conditional]*则后面还可以跟进一步的 *for* 或*。*

让我们来看一些例子，看看它们是如何工作的:

```
*x = [i for i in range(10)]*
```

产生结果:

```
*[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]*
```

并且利用条件语句:

```
*x = [i for i in range(10) if i > 5]*
```

返回列表:

```
*[6, 7, 8, 9]*
```

因为条件 *i > 5* 被检查。

除了比 for 循环更简洁、可读性更强之外，列表的理解也明显更快。

### 嵌套列表理解

使用嵌套列表理解，生成、转置和展平列表列表变得更加容易。大多数关键字和元素类似于基本的列表理解，只是再次用于更深一层。

为了进行演示，请考虑以下示例:

```
*[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]*
```

结果是:

```
*[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]*
```

### 复杂表达式和嵌套函数

您还可以在列表理解中使用函数和复杂表达式。

例如:

```
*from math import pi  # import pi number from math module*

*[str(round(pi, i)) for i in range(1, 6)]*
```

退货:

```
*['3.1', '3.14', '3.142', '3.1416', '3.14159']*
```

列表理解对于产生更紧凑的代码行是理想的。它们也可以用来完全取代 -loops 的*，以及 *map()、filter()、*和 *reduce ()* 函数，这些函数经常与 lambda 函数一起使用。*

### 词典释义

在 Python 中，字典理解与列表理解非常相似——只适用于字典。它们提供了从 iterable 创建字典或将一个字典转换成另一个字典的优雅方法。

语法类似于用于列表理解的语法，即*{ key:item-iterator 中的 item 表达式}、*，但是注意包含了表达式对 *(key:value)* 。

让我们看一个简单的例子来制作字典。代码可以写成

```
*dict([(i, i+10) for i in range(4)])*
```

**其中** **相当于:**

```
*{i : i+10 for i in range(4)}*
```

在这两种情况下，返回值都是:

```
*{0: 10, 1: 11, 2: 12, 3: 13}*
```

这个基本语法后面还可以跟附加的 *for* 或 *if* 子句:*{ key:item-item in iterator if conditional }*。

使用一个 *if* 语句可以过滤出值来创建新的字典。

例如:

```
*{i : i+10 for i in range(10) if i > 5}*
```

退货:

```
*{6: 16, 7: 17, 8: 18, 9: 19}*
```

类似于列表理解，对于-循环和 lambda 函数，字典理解也是*的强大替代。*循环的*，尤其是*循环的嵌套*，会变得复杂和混乱。字典理解提供了一种更简洁的方式来编写相同的代码，使其更容易阅读和理解。*

### 嵌套词典理解

在 Python 中，字典理解也可以嵌套，在另一个字典理解中创建一个字典理解。

例如:

```
*{(k, v): k+v for k in range(2) for v in range(2)}*
```

退货:

```
*{(0, 0): 0, (0, 1): 1, (1, 0): 1, (1, 1): 2}*
```

使用具有复杂字典结构的嵌套字典理解时要小心。在这种情况下，字典理解也变得更加复杂，并可能抵消试图产生简洁、可理解的代码的好处。

## Python 中的生成器表达式

生成器表达式是比传统的基于类的迭代器更高效的高性能代码编写方式的又一个例子。为了更好地理解生成器表达式，我们先来看看什么是生成器以及它们是如何工作的。

### 发电机功能

Python 中基于类的迭代器通常很冗长，需要很大的开销。另一方面，生成器能够执行相同的功能，同时自动减少开销。

生成器相对容易创建；正规函数是用 yield 语句而不是 return 语句定义的。yield 语句的作用是暂停函数并保存其本地状态，以便后续调用从中断处继续。

发电机的工作方式如下:

*   调用生成器函数时，它不会立即执行，而是返回一个生成器对象。

*   在生成器对象上调用 *next()* 之前，代码不会执行。

*   调用 yield 后，控制权会暂时传递回调用者，函数会暂停。

*   局部变量及其执行状态存储在调用之间。

*   当函数完成时，会自动引发 StopIteration。

生成器函数可以写成:

```
*def gen():*

 *for x in range(10):*

 *yield x**2*
```

### 生成器表达式

生成器表达式使得动态构建生成器变得容易，不需要使用 *yield* 关键字，甚至比生成器函数更简洁。

与上例中相同的代码可以写成:

```
*g = (x**2 for x in range(10))*
```

生成器的另一个有价值的特性是能够根据条件过滤掉元素。

我们来看一个例子 **:**

```
*gen_exp = (i ** 2 for i in range(10) if i > 5)*

*for i in gen_exp:*

 *print(i)*
```

退货:

```
*36*

*49*

*64*

*81*
```

### 生成器表达式与列表理解

生成器表达式的语法与列表理解的语法惊人地相似，唯一的区别是圆括号的使用与方括号相反。

例如，生成器表达式可以写成:

```
*(i ** 2 for i in range(10) if i > 5)*
```

与列表理解相比，列表理解写为:

```
*[i ** 2 for i in range(10) if i > 5]*
```

然而，它们的不同之处在于返回的数据类型。列表理解将返回整个列表，而生成器表达式将返回一个生成器对象。虽然值与列表中的值相同，但是通过使用 *next()* 函数一次访问一个值。

就速度而言，列表理解通常比生成器表达式快，尽管在处理的数据量大于可用内存的情况下并非如此。最重要的是，因为生成器表达式只按需生成值，而列表理解需要内存来生成整个列表，所以生成器表达式的内存效率要高得多。

生成器表达式非常适合处理大型数据集，当您不需要一次得到所有结果，或者希望避免为将要产生的所有结果分配内存时。它们也非常适合表示无限的数据流，因为一次只能产生一个项目，消除了无法在内存中存储无限流的问题。

与列表理解一样，您应该小心使用嵌套表达式，这些表达式复杂到难以阅读和理解的程度。

## 包扎

Python for-loops 在处理重复性编程任务时非常有价值，但是，还有其他方法可以让您更有效地获得相同的结果。列表理解和字典理解是对循环和 lambda 函数的强大替代。列表和字典理解不仅使代码更加简洁易读，而且比传统的循环的*更快。然而，成功的关键是不要让它们变得太复杂，以至于一开始就否定了使用它们的好处。*

类似地，生成器和生成器表达式提供了一种创建迭代器的高性能和简单的方法。尽管在语法上与列表理解相似，但生成器表达式仅在需要时才返回值，而不是在前一种情况下返回整个列表。因此，它们使用的内存更少，效率更高。