<html>
<head>
<title>React and Rx.js - The Power Of Observable (FAQ) Netguru | Codestories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React和Rx.js -可观察的力量(常见问题解答)</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/react-rxjs#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/react-rxjs#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>RxJS是什么？</p><p>RxJS是一个库，用于通过使用可观察序列来编写异步和基于事件的程序。它提供了一个核心类型，即<a href="http://web.archive.org/web/20221007150033/https://rxjs-dev.firebaseapp.com/guide/observable">可观察的</a>，卫星类型(观察者、调度器、主体)，以及受Array#extras启发的操作符(map、filter、reduce、every等)。)来允许将异步事件作为集合来处理。</p></div><p>ReactiveX将<a href="http://web.archive.org/web/20221007150033/https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>与<a href="http://web.archive.org/web/20221007150033/https://en.wikipedia.org/wiki/Iterator_pattern">迭代器模式</a>和<a href="http://web.archive.org/web/20221007150033/http://martinfowler.com/articles/collection-pipeline/#NestedOperatorExpressions">函数式编程与集合</a>相结合，以满足管理事件序列的理想方式的需求。</p>
<p>RxJS中解决异步事件管理的基本概念如下。</p>
<ul>
<li><strong>可观察:</strong>代表未来值或事件的可调用集合的想法。</li>
<li><strong> Observer: </strong>是一个回调集合，它知道如何监听被观察对象传递的值。</li>
<li><strong>认购:</strong>代表可观察的执行；它主要用于取消执行。</li>
<li><strong>操作符:</strong>是纯函数，支持函数式编程风格，通过映射、过滤、连接、归约等操作来处理集合。</li>
<li><strong> Subject: </strong>相当于EventEmitter，是向多个观察者多播值或事件的唯一方式。</li>
</ul>
<p><strong>调度器:</strong>是控制并发性的集中调度器，允许我们在计算发生时进行协调，例如setTimeout或requestAnimationFrame或其他。</p>
<h2>去哪里学Rx？</h2>
<p>第一个电话肯定是去RxJS主网页:</p>

<p>文档非常详细，并且呈现得很好，大部分概念都涉及得很深，这很好，但有时会使人很难快速理解。</p>
<p>因此，当我阅读一些更复杂的概念时，我发现有更多的首次rx用户友好教程:</p>
<ul>
<li><a href="http://web.archive.org/web/20221007150033/https://www.learnrxjs.io/">https://www.learnrxjs.io/</a>(这对于学习或快速检查如何与一些接收操作员合作特别有用)</li>
</ul>
<p>至于将<a href="/web/20221007150033/https://www.netguru.com/blog/next-js-vs-react" rel="noopener"> React </a>与Rx结合起来，有很多文章你可能想看看:</p>

<p>其他文章:</p>

<h2>我可以用Rx做什么？</h2>
<ul>
<li>RxJS非常适合复杂的异步查询和对事件的反应。使用RxJS和lodash，在这些情况下很容易编写干净的代码。</li>
<li>您可以使用RxJS来处理和限制用户事件，从而更新应用程序的状态。</li>
<li>有了React，它非常适合在组件之间创建通信。</li>
<li>它提供了允许开发人员创建数据流并对这些数据流进行操作的方法。有如此多的操纵或创造的选择，所以你有一个大的领域可以发挥(例如，你可以使用它与Websockets)。</li>
<li>对于任何涉及时间概念的工作，或者当您需要推理可观测的历史值/事件(而不仅仅是最新的)时，推荐使用RxJS，因为它提供了更多的底层原语。</li>
</ul>
<h2>用Rx不爽的时候？</h2>
<ul>
<li>维护——你的团队对Rx有经验吗？如果没有，新人可能很难学习Rx js，因为它有一个相当陡峭的学习路径。</li>
<li>调试起来相当困难。记录器有时只显示源代码深处的函数，所以您需要深入研究——或者只是猜测——哪里出错了。</li>
<li>此外，对于某些项目来说，这可能有些矫枉过正。</li>
<li>它也有优点和缺点，但是有如此多的操作符，您可以在一个管道中组合，并且很容易迷路(调试)。</li>
</ul>
<h2>我可能会陷入哪些问题？</h2>
<p>RxJS的问题可能是它只是一个实用程序，它没有向人们展示如何设计他们的应用程序，以便解决一些常见的难题:</p>
<ul>
<li>检查应用程序的当前状态，</li>
<li>组合其值无序的流，</li>
<li>组合其值可能不完整的流，</li>
<li>处理超时，</li>
<li>处理过时的流数据，</li>
<li>取消飞行中的流操作，</li>
<li>流的条件行为，</li>
<li>重试机制。</li>
</ul>
<p>由于RxJS是在一元编程之后建模的，如果架构正确，所有这些都可以解决，但是如果没有适当的经验，它们也不是微不足道的。</p>
<h2>MobX是不是已经不像Rx store实现了？</h2>
<p>MobX是状态管理器，RxJS是处理异步事件的库。</p>
<p>至于MobX，文档说:</p>
<p><strong><i>MobX可以和RxJS结合吗？</i>T3】</strong></p>
<p><i>是的，你可以从mobx-utils </i>  <i>中使用</i> <a href="http://web.archive.org/web/20221007150033/https://github.com/mobxjs/mobx-utils#tostream"> <i> toStream和fromStream来使用RxJS和其他与mobx兼容的TC 39 observable。</i></a></p>
<p><strong> <i>什么时候用RxJS代替MobX？</i>T3】</strong></p>
<p>对于任何涉及明确使用时间概念的工作，或者当你需要推理一个可观察的历史值/事件(而不仅仅是最新的)时，推荐使用RxJS，因为它提供了更多的底层原语。每当您想对状态而不是事件做出反应时，MobX提供了一种更简单、更高级的方法。实际上，结合RxJS和MobX可能会产生真正强大的结构。例如，使用RxJS来处理和抑制用户事件，并作为更新状态的结果。如果MobX可以观察到状态，它就会相应地更新UI和其他派生。</p>
<p>将MobX与RxJS一起使用可能也是一个好主意，但是您将需要安装一些其他的依赖项。</p>
<h2>与RxJS反应:</h2>
<p>在根项目目录中安装必要的依赖项:</p>
<pre>npm install rxjs<br/>npm install rxjs-compat</pre>
<p>让我们关注一个真实的例子，一个fetch调用需要开发人员执行多个数据操作步骤和额外的API调用来获取加载应用程序所需的数据。</p>
<p>这是我连接到redux状态的主要组件；</p>
<pre class="language-javascript"><code class="language-javascript">
class Main extends Component {
  subscription;

  constructor() {
    super();
    this.search$ = new Subject();
    this.search = this.search$.asObservable().pipe(
      debounceTime(500),
    );
  }

  componentDidMount() {
    this.subscription = this.search.subscribe((text) =&gt; {
      this.callApiToGetHeroes(text);
    });
  }

  componentWillUnmount() {
    this.subscription.unsubscribe();
  }

  onSearch = (e) =&gt; {
    this.search$.next(e.target.value);
  }

  render() {
    const { listOfHeroes, team } = this.props;
    return (
      &lt;div className="main_view"&gt;
        &lt;Header /&gt;
        &lt;SearchBar onSearch={this.onSearch} /&gt;
        &lt;div className="main_view_list_container"&gt;
          &lt;HeroList heroesList={listOfHeroes} /&gt;
          &lt;ChosenList chosenList={team} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

Main.propTypes = {
  listOfHeroes: PropTypes.arrayOf(PropTypes.object),
  team: PropTypes.arrayOf(PropTypes.object),
  getHeroes: PropTypes.func,
};

Main.defaultProps = {
  listOfHeroes: [],
  team: [],
  getHeroes: null,
};

const mapStateToProps = (state) =&gt; ({ team: state.team, listOfHeroes: state.list });

const mapDispatchToProps = (dispatch) =&gt; ({
  getHeroes: () =&gt; dispatch(getHeroesAction()),
});

export default connect(mapStateToProps, mapDispatchToProps)(Main);</code></pre>
<p>为了在主组件中创建反应性输入，它需要有一个可观察的创建者——在本例中是一个主体。</p>
<p>为了抑制API请求，我在observable中添加了debounceTime(500 ),这样它将在下一次调用之前等待500 ms。</p>
<p>主题只是创造可观察事物的一种方式。</p>
<p><strong>重要通知:</strong>unsubscribe()observable on component will unmount用于防止组件被破坏后，组件外还存在observable，这样可以避免内存泄漏。</p>
<p>API调用:</p>
<pre><code class="language-javascript"><span>import 'babel-polyfill';
import { fromFetch } from 'rxjs/fetch';
import {
  switchMap,
  map,
  tap,
  flatMap,
} from 'rxjs/operators';
import { forkJoin } from 'rxjs';
import 'rxjs/add/observable/of';

import { ADD_TO_CHOSEN, REMOVE_FROM_CHOSEN, FETCH_HEROES_SUCCESS } from './types';

const fetchUrl = 'https://swapi.co/api/people/';
const imgUrl = 'https://i.pravatar.cc/200?img=';

export const addHero = (hero) =&gt; ({ type: ADD_TO_CHOSEN, hero });
export const removeHero = (hero) =&gt; ({ type: REMOVE_FROM_CHOSEN, hero });
export const getHeros = (heros) =&gt; ({ type: FETCH_HEROES_SUCCESS, heros });


const getWorlds = (list) =&gt;
  forkJoin(list.map((hero) =&gt;
   fromFetch(hero.homeworld)
      .pipe(
        switchMap((resp) =&gt; resp.json()),
        map((resp) =&gt; ({ ...hero, homeworld: resp.name })),
      )));

const getSpecies = (list) =&gt;
 forkJoin(list.map((hero) =&gt;
  fromFetch(hero.species[0])
      .pipe(
        switchMap((resp) =&gt; resp.json()),
        map((resp) =&gt; ({ ...hero, species: [resp.name] })),
      )));
      
const handleResponse = (resp) =&gt;{
   if (resp.ok) {
     return resp.json();
   } else {
     return of({ error: true, message: `Error ${resp.status}` });
   }
}
      
export const getHeroesAction = () =&gt;
   (dispatch) =&gt;
    fromFetch(fetchUrl)
      .pipe(
        switchMap((response) =&gt; handleResponse(response)),
        map((response) =&gt; response.results),
        flatMap((response) =&gt; getWorlds(response)),
        flatMap((response) =&gt; getSpecies(response)),
        tap((completeHeroes) =&gt; dispatch(getHeros(completeHeroes))),
        catchError((err) =&gt; {
          console.error(err);
          return of({ error: true, message: err.message });
        }),
      );</span></code></pre>
<p>因此，我将尝试解释那里发生了什么<a class="sc-gPWkxV gPokKt" href="http://web.archive.org/web/20221007150033/https://www.learnrxjs.io/" title="https://www.learnrxjs.io/">(单击此处查看运营商文档以获得完整描述)</a></p>
<p>我们从<strong> <span data-mark-type="annotation" data-mark-annotation-type="inlineComment" data-id="6e7fc709-bcc5-49ef-998b-acfe1da909ed"> fromFetch </span> </strong>开始，它将基本的Fetch调用转换为<span class="code">可观察的&lt;响应&gt; </span> ( &lt;可观察的&gt;类型)它也可以用<span> <strong> fromPromise </strong>来完成(不推荐用于版本&lt; 6)。)</span>或中的<strong>。</strong></p>
<p><strong>管道</strong>操作符允许在observable用一些Rx操作符发出之前操纵数据流。在这种情况下，<strong> <span data-mark-type="annotation" data-mark-annotation-type="inlineComment" data-id="9f1c9d2c-9de4-48da-9353-ba0242c792e8"> switchMap </span> </strong> <span data-mark-type="annotation" data-mark-annotation-type="inlineComment" data-id="9f1c9d2c-9de4-48da-9353-ba0242c792e8">处理来自服务器的响应(它也取消以前的可观察性)。而</span><strong>映射</strong>操作符允许转换可观察值。</p>
<p><a class="sc-gPWkxV gPokKt" href="http://web.archive.org/web/20221007150033/https://blog.angular-university.io/rxjs-higher-order-mapping/" title="https://blog.angular-university.io/rxjs-higher-order-mapping/">(如果Rx地图有点混乱，请点击这里)</a>或<a class="sc-gPWkxV gPokKt" href="http://web.archive.org/web/20221007150033/https://medium.com/@luukgruijs/understanding-rxjs-map-mergemap-switchmap-and-concatmap-833fc1fb09ff" title="https://medium.com/@luukgruijs/understanding-rxjs-map-mergemap-switchmap-and-concatmap-833fc1fb09ff">点击这里</a></p>
<p>接下来，Rx魔术开始了——问题是响应数据的结构——hero object中的一些值只是从另一个源获取值的urls使用Rx，我们可以在一个流中完成所有工作！&lt; B</p>
<p>forkJoin 的工作方式有点像promise . all——它加入并等待所有内部可观察对象发出，然后返回新的可观察对象以及来自内部可观察对象的数据。它非常适合有多个http请求的情况。</p>
<p><strong> flatMap </strong>在这里用于展平用forkJoin创建的可观察对象，并在流上继续；</p>
<p>接下来的两个操作非常简单- <strong>点击</strong></p>

<p><strong> catchError </strong>允许捕捉错误并以我们想要的方式转换它。</p>
<h2 id="What-about-testing?">测试呢？</h2>
<p>嗯，这非常简单——只是为了测试react应用程序中的一些流，我认为最好的方法是将我们的管道从组件中取出，并与其他操作符一起保存在一个单独的文件中——然后测试每个流的效果就变得非常容易了。仅仅举个例子:</p>
<pre><code class="language-javascrip"> <span>export const simpleMapTest = (observable$) =&gt; {
  return observable$.pipe(
    map(data =&gt; data + ' search'),
  )
};</span></code></pre>
<p><span>和测试:</span></p>
<pre><code class="language-javascript"><span>it('should change value of the observable', (done) =&gt; {
  const observable$ = of('text');
  simpleMapTest(observable$).subscribe((value) =&gt; {
    expect(value).toBe('text search');
    done();
  });
});</span></code></pre>
<p>至于测试组件，我们不能真的订阅组件观察值，但是我们可以测试我们的流对这个组件的影响。让我们从前面创建的输入中取出去抖操作符。这个动作的测试应该是这样的:</p>
<pre><code class="language-javascript"><span class="token">it</span><span class="token punctuation">(</span><span class="token">'should execute call API to get Heroes only once'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token">const</span><span> wrapper </span><span class="token operator">=</span> <span class="token">shallow</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span>MainComponent </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token">const</span><span> shallowComponent </span><span class="token operator">=</span><span> wrapper</span><span class="token punctuation">.</span><span class="token">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span>
  shallowComponent</span><span class="token punctuation">.</span><span>callApiToGetHeroes </span><span class="token operator">=</span><span> jest</span><span class="token punctuation">.</span><span class="token">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span>
  wrapper</span><span class="token punctuation">.</span><span class="token">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span>
  shallowComponent</span><span class="token punctuation">.</span><span class="token">onSearch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span> target</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span> value</span><span class="token punctuation">:</span> <span class="token">'text'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span>
  shallowComponent</span><span class="token punctuation">.</span><span class="token">onSearch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span> target</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span> value</span><span class="token punctuation">:</span> <span class="token">'text1'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span>
  shallowComponent</span><span class="token punctuation">.</span><span class="token">onSearch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span> target</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span> value</span><span class="token punctuation">:</span> <span class="token">'text3'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token">expect</span><span class="token punctuation">(</span><span>shallowComponent</span><span class="token punctuation">.</span><span>callApiToGetHeroes</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token">toHaveBeenCalledTimes</span><span class="token punctuation">(</span><span class="token">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token">expect</span><span class="token punctuation">(</span><span>shallowComponent</span><span class="token punctuation">.</span><span>callApiToGetHeroes</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token">toHaveBeenCalledWidth</span><span class="token punctuation">(</span><span class="token">'text3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="Summary:"><span data-mark-type="annotation" data-mark-annotation-type="inlineComment" data-id="7b8d1b46-c144-4a68-88a1-80ed828cd811">概要:</span></h2>
<p>对于有经验的开发人员来说，Rx.js是一个很好的工具，它可以很容易地在React环境中实现，但缺点是对于从未在任何项目中使用过Rx的人来说，第一次接触React方法可能是一件很困难的事情。</p>
<p>Rx.js远不止本文涵盖的主题，所以我鼓励大家做一些研究，在掌握了基本概念之后，你可以<a class="sc-gPWkxV gPokKt" href="http://web.archive.org/web/20221007150033/https://rxmarbles.com/" title="https://rxmarbles.com/">进入rx.js弹珠</a>。</p>
<p> </p>
<p><span data-style-font-style-italic="">图片由</span> <a href="http://web.archive.org/web/20221007150033/https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-style-font-style-italic=""> Artem Sapegin </a> <span data-style-font-style-italic="">在</span> <a href="http://web.archive.org/web/20221007150033/https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-style-font-style-italic=""> Unsplash </a></p></span></div>    
</body>
</html>