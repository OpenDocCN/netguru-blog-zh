<html>
<head>
<title>Say Goodbye to SharedPreferences - Meet DataStore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>告别SharedPreferences - Meet数据存储</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/say-goodbye-to-sharedpreferences-meet-datastore#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/say-goodbye-to-sharedpreferences-meet-datastore#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>前段时间，谷歌推出了Android Jetpack的一个新部分，DataStore。这是一个应该取代SharedPreferences的库。这就是这个吸引人的标题的原因:迟早，我们所有人都可能被迫转向数据存储。</p></div><p>这两个API之间有一些相似之处，但是DataStore提供了更多的灵活性。它有两种不同的储物方式。第一个是简单的键值对存储，就像SharedPreferences一样。第二种类型是Proto DataStore，更有趣也更复杂。它基于Google的Protobuf库，允许我们创建更复杂的数据结构。整个数据存储目前在alpha中。在深入讨论细节之前，让我们先来看一下DataStore和SharedPreferences之间的比较。</p>
<h2>共享首选项和数据存储比较</h2>

<p> </p>
<ul>
<li>DataStore构建在Kotlin协同例程和流之上，因此它为修改和读取数据提供了一个非常好的异步API。另一方面，SharedPreferences只通过一个侦听器来提供异步访问。</li>
<li>可以在UI线程上调用DataStore，没有任何问题。它将调度程序改为引擎盖下的IO。</li>
<li>数据存储在数据解析期间也不会出现运行时异常。</li>
</ul>
<p>值得一提的是，数据存储不是空间的替代品。它只适用于小型数据集以及不需要部分更新或参照完整性的情况。如果你需要这些，考虑使用房间。</p>
<h2>数据存储的类型</h2>
<p>如前所述，我们有两种类型的数据存储可用:</p>
<ul>
<li>Preferences DataStore，它与SharedPreferences非常相似。它存储键值对，不提供任何类型安全。</li>
<li>更复杂的数据存储原型。它可以在自定义对象中存储数据。由于这一点，它提供了开箱即用的类型安全。在设置过程中需要做更多的工作，因为需要使用<a href="http://web.archive.org/web/20221006050453/https://developers.google.com/protocol-buffers"> <span>协议缓冲区</span> </a> <span>创建一个模式。</span> <br/> <span/></li>
</ul>
<h2><span>偏好数据存储</span></h2>
<p>首先，让我们看看键值存储。设置非常简单。要开始使用这个版本的DataStore，只需向应用程序的build.gradle添加一个依赖项。</p>
<pre><code class="language-groovy">// Preferences DataStore
implementation "androidx.datastore:datastore-preferences:1.0.0-alpha02"</code></pre>
<p>我创建了一个简单的ProfilePreferences类来处理数据存储。基本上，Preferences中只存储一个简单的布尔值。它确定是否可以更改配置文件信息。</p>
<pre><code class="language-kotlin">
class ProfilePreferences(context: Context) {

	private val dataStore: DataStore&lt;Preferences&gt; = context.createDataStore(
    	"profile",
    	migrations = listOf(SharedPreferencesMigration(context, "oldProfilePreferences"))
    )
	val editStateFlow: Flow&lt;Boolean&gt; = dataStore.data
    	.map{ it[EDIT_MODE_ENABLED_KEY] ?: true }
    
	suspend fun toggleEditMode(enabled: Boolean) {
    	dataStore.edit {
        	it[EDIT_MODE_ENABLED_KEY] = enabled
       	}
 	}
    
	companion object {
		private val EDIT_MODE_ENABLED_KEY = preferencesKey&lt;Boolean&gt;("edit_mode_enabled")
  	}
}</code></pre>
<ul>
<li>ProfilePreferences需要上下文来创建数据存储。有了这些信息，我们可以使用扩展函数<code>createDataStore()</code>并传递数据存储的名称。</li>
<li>可以从SharedPreferences添加迁移。只需传递一个带有要迁移的首选项名称的SharedPreferenceMigration对象。</li>
<li>DataStore不使用普通字符串作为键，它们由Key a类包装。要获得特定的密钥，需要使用<code>preferencesKey&lt;T&gt;(name)</code>。Type T是存储在此项下的值的所需类型。</li>
<li>要更改存储的值，我们可以使用DataStore对象中的<code>edit()</code>函数。在lambda中，我们可以访问MutablePreferences，因此我们可以更改指定键下的值。<code>edit()</code>函数是一个挂起函数，因此需要从CoroutinesContext中调用。</li>
<li>为了获得存储的偏好，我们可以访问<code>dataStore.data</code>下的<code>Flow&lt;Preferences&gt;</code>。使用<code>map{}</code>操作符，我们可以得到<code>Flow&lt;Boolean&gt;</code>。</li>
</ul>
<p>要更改EDIT_MODE的值，只需使用ViewModel中<code>ProfilePreferences</code>的<code>toggleEditMode()</code>方法。</p>
<pre><code class="language-kotlin">
fun toggleEditMode(enabled: Boolean) {
	viewModelScope.launch {
		profileRepository.toggleEditMode(enabled)
	}
}
</code></pre>
<p>当该操作完成时，使用Flow共享一个新值。在我们的例子中，我使用<code>asLiveData()</code>扩展将该流转换成LiveData，并且在活动中观察到了这一点。</p>
<pre><code class="language-kotlin">
val editEnabled = profileRepository.editStateFlow.asLiveData()

viewModel.editEnabled.observe(this) {
	with(binding) {
		name.isEnabled = it
		surname.isEnabled = it
	}
}
</code></pre>
<p>很容易使用，对吧？现在让我们跳到原型数据存储示例。</p>
<h2>原型数据存储</h2>
<p>正如我之前提到的，Proto DataStore可以存储定制数据的实例。为此，您必须使用<a href="http://web.archive.org/web/20221006050453/https://developers.google.com/protocol-buffers"> <span>协议缓冲区</span> </a>来定义该数据的模式。我的项目中使用的示例模式如下所示。</p>
<pre><code>
syntax = "proto3";
option java_package = "com.netguru.datastoresample";
option java_multiple_files = true;

message ProfileInfo {
	string surname = 1;
	string name = 2;
}
</code></pre>
<p>如您所见，除了数据结构，还有其他选项。默认情况下，缓冲区使用<code>proto2</code>,所以为了使用最新的语法，我们必须显式地提供它。另外两个选项定义了应该在哪里以及如何创建生成的Java类。这个文件中最后也是最重要的是消息定义。这是编译器应该如何生成新类的模式。</p>
<p>当我写这篇文章时，Proto DataStore的<a href="http://web.archive.org/web/20221006050453/https://developer.android.com/topic/libraries/architecture/datastore#proto-datastore"> <span>文档</span> </a>缺少一些关于配置部分的细节。基于这些文档，有人会认为这就足够了。不幸的是，情况并非如此，我发现要正确设置一切有点困难。缺少关于基于定义的模式生成Java类的部分。</p>
<p>我选择了<a href="http://web.archive.org/web/20221006050453/https://github.com/square/wire"> <span>线</span> </a>进行代码生成。也有一些官方的Google工具，但是Wire可以生成Kotlin类。它是专门为Android设计的，因此优化得更好，生成的代码也更干净。Google tools生成的同一个类有大约400行代码，而Wire只生成了130行。Wire生成的类也是可打包的，所以我们可以简单地通过一个包来传递它们。说到配置，我们需要几样东西:</p>
<ul>
<li>插件，你应该添加到你的根版本中。</li>
</ul>
<pre><code>classpath "com.squareup.wire:wire-gradle-plugin:3.3.0"</code></pre>
<p>你还需要在你的应用程序的build.gradle中添加这个插件。</p>
<pre><code>apply plugin: 'com.squareup.wire'</code></pre>
<ul>
<li>接下来，您需要添加Protobuf运行时库和编译器。</li>
</ul>
<pre><code>implementation "com.squareup.wire:wire-runtime:3.3.0"<br/><br/>implementation "androidx.datastore:datastore-core:1.0.0-alpha02"<br/></code></pre>
<p>最后但同样重要的是，为Gradle插件添加配置块。</p>
<pre><code class="laguage-groovy">
wire {
  kotlin {	
    android = true
  }
}
</code></pre>
<p>如果您已经准备好了模式，只需重新构建项目，一切都将正确生成。</p>
<p>让我们回到模式示例。</p>
<pre><code>
message ProfileInfo {
	string surname = 1;
	string name = 2;
}
</code></pre>
<p>Protobuffers支持几种数据类型。首先，它们可以存储所有标量，如整数、双精度数等。我们也可以使用枚举甚至其他消息作为类型。更多信息，可以查看<a href="http://web.archive.org/web/20221006050453/https://developers.google.com/protocol-buffers/docs/overview#simple"> <span>文档。</span>T3】</a></p>
<p>提供的示例模式仅包含2个字符串字段。编译器将基于该消息创建一个ProfileInfo类。不要将分配给字段的数字与默认值混淆。这些数字是生成器添加到这些值中的标签。</p>
<p>当我们已经有了一个生成的模型类时，我们需要创建一个序列化器来持久化这些数据。</p>
<pre><code class="language-kotlin">
object ProfileInfoSerializer : Serializer&lt;ProfileInfo&gt; {

	override fun readFrom(input: InputStream): ProfileInfo {
		try {
			return ProfileInfo.ADAPTER.decode(input)
		} catch (exception: InvalidProtocolBufferException) {
			throw CorruptionException("Cannot read proto.", exception)
		}
	}

	override fun writeTo(t: ProfileInfo, output: OutputStream) = ProfileInfo.ADAPTER.encode(output,t)
}
</code></pre>
<p>它可能看起来像样板代码，而且在大多数情况下可能会是这样。但是，通过这种抽象，我们可以在将数据保存到数据存储之前对其进行加密。</p>
<p>最后，让我们看看数据存储本身的使用和创建。它看起来非常类似于首选项数据存储。</p>
<pre><code class="language-kotlin">
class ProfileStore(context: Context) {

	private val dataStore: DataStore&lt;ProfileInfo&gt; = context.createDataStore(
    	fileName = "basket_item.pb", 
        serializer = ProfileInfoSerializer
   	)
	
    val profileInfoFlow = dataStore.data

	suspend fun changeName(name: String) {
		dataStore.updateData {
			it.copy(name = name)
		}
	}

	suspend fun changeSurname(surname: String) {
		dataStore.updateData {
 			it.copy(surname = surname)
		}
	}
}
</code></pre>
<p>要创建一个原型数据存储，我们需要提供一个存储数据的文件名和我们之前创建的序列化程序。</p>
<p>如果您想从SharedPreferences迁移到Proto DataStore，您可以。您所要做的就是创建一个map函数，将SharedPreferences中的数据添加到model类的特定字段中。</p>
<pre><code class="language-kotlin">
private val dataStore: DataStore&lt;ProfileInfo&gt; = context.createDataStore(
	fileName = "profile_info.pb", 
    serializer = ProfileInfoSerializer,
	migrations = listOf(SharedPreferencesMigration(context,"profile_preferences") 
    { sharedPreferences: SharedPreferencesView, profileInfo: ProfileInfo -&gt;
		// Map preferences into profile info
	})
)
</code></pre>
<h2>摘要</h2>
<p>与SharedPreferences相比，DataStore有许多优势。一个是对协程和流的支持，这使得异步读写成为可能，并且可以安全地从UI线程调用。然后是对错误处理的支持。在我看来，这将是SharedPreferences的一个很好的替代品。迁移选项使它变得更好，因为它可以在任何项目中实现，而不仅仅是在新项目中。我鼓励您尝试一下，即使是在一个示例项目中，并且更加熟悉这个库。</p>
<p><span>照片由<a href="http://web.archive.org/web/20221006050453/https://unsplash.com/@switch_dtp_fotografie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">卢卡斯·范·奥尔特</a>拍摄于<a href="http://web.archive.org/web/20221006050453/https://unsplash.com/s/photos/storage-container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a>T5】</span></p></span></div>    
</body>
</html>