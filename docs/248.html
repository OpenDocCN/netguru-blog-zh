<html>
<head>
<title>Check out why Room is a Retrofit for SQLite - pt. 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解为什么房间是SQLite - pt的改型。一</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/check-out-why-room-is-a-retrofit-for-sqlite-pt.-1#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/check-out-why-room-is-a-retrofit-for-sqlite-pt.-1#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>谷歌I/O 2017相当具有革命性。我们已经看到了许多令人惊叹的新产品发布，并听说谷歌将在机器学习相关技术上投入大量资金。</p> 
<p>今年的I/O对于Android开发者来说也是非同寻常的，因为我们终于获得了对Kotlin的官方支持(耶！)和一个全新的名为“Android架构组件”的Android库集合。</p></div><p> </p>
<p>现在是测试新解决方案的时候了。之前，我们研究了<a href="/web/20220925022810/https://www.netguru.com/blog/android-components-comparison-mvvm-vs-mvp" rel="noopener">新的生命周期组件</a>和 <span>现在，我们将深入研究Room Persistence Library，它有可能成为本地存储的新改进——不仅因为它的受欢迎程度，还因为您在使用它时会发现两者之间的相似之处。</span></p>
<h2><span>老办法</span></h2>
<p><span>目前，clean SQLite几乎被遗忘，并不真正存在于商业项目中。尽管它仍然是官方文档推荐的唯一数据库解决方案，并能让您很好地(如果不是最好的话)控制本地存储，但是使用它的代价太高了。原因是开发人员最终会产生大量样板文件，编写所有的查询，然后将它们转换成Java对象。对于没有SQL知识的人来说，这可能是个问题，更不用说缺少对任何反应组件的默认支持，而这正是一些ORM的巨大优势。</span></p>
<p>在编写SQL查询的过程中，错误是不可避免的，最糟糕的是，直到你编译你的应用程序并尝试执行你的查询时，你才会知道这些错误。其中一些问题已经在SQLBrite和SQLDelight等流行的库中解决了，但是使用这些库仍然不容易，学习曲线是指数级的。正因为如此，Android上与持久性相关的库的数量很大，我们的选择太多了。</p>
<p>在Netguru，我们测试了许多可用的解决方案，作为这项研究的结果，我们主要选择了Realm和greenDAO，它们成为了我们默认堆栈的一部分。我们接受了它们的优点，也接受了它们的缺点，但是随着时间的推移，新的解决方案不断出现，所以我们决定测试Room。</p>
<h2>你知道翻新吗？房间将是小菜一碟。</h2>
<p>就像retrieve在HTTP调用上构建抽象一样，Room在SQL查询上构建抽象。要创建一个改型并设置一个客户端，您使用 <i> <span>改型。</span> </i>建造者()<span>。通过使用客户端，您可以通过调用</span><i><span>reflect . create(...)</span> </i> <span>并简单地为它提供一个描述你的调用的接口，这是使用各种注释完成的。</span></p>
<p>Room采取了类似的方法，但是DAO接口注册在一个扩展RoomDatabase的类中。然后通过调用Room.databaseBuilder(...)并传递一个扩展RoomDatabase的抽象类。Room将生成您的接口的正确实现，就像retrieve所做的那样，您将能够通过由构建器返回的数据库类的实现来访问这些接口。通过为远程和本地存储访问定义相同的接口，甚至可以在翻新和房间之间共享数据访问接口。</p>
<p>尽管如此，这并不是一个有趣的事实，因为它在很少的情况下会工作得很好，而且你应该知道这个解决方案的缺点和限制，我将在本文的第二部分中分享<a href="/web/20220925022810/https://www.netguru.com/blog/check-out-why-room-is-a-retrofit-for-sqlite-pt.-2" rel="noopener">。就像翻新一样，Room提供了对RxJava2的支持。</a></p>
<h2>房间能做什么？</h2>
<p>它将为您执行查询并将查询转换为Java对象，其方式可能类似于您从Retrofit和Gson中了解到的方式。它将为您创建表，因此不再需要创建表查询。它将允许您轻松地构建反应式数据流。</p>
<h2><span>房间不能做什么？</span></h2>
<p>Room不会为您处理对象引用(尽管可以通过对我们的类类型使用@Embedded注释将对象嵌入到表中)。这是房间设计的一个特点，所以不允许放置任何反映对象之间关系的字段-必须通过引用主键来完成。</p>
<p>在我们的例子中，这意味着我们不能在TaskDb中创建一个ChecklistItemDb的列表来反映我们的一对多关系。为什么？一些ORM(比如greenDAO，它允许您创建对象依赖关系)是延迟初始化的，其结果是当您调用getter返回关系中的另一个对象时，您实际上是在进行另一个查询。糟糕的设计可能会导致开发人员或代码审查人员甚至没有注意到在UI线程上进行这样的调用，我们都知道进行这样的调用不是一个好主意，因为它可能会导致帧率下降。</p>
<p>实际上，对于UI线程上的调用，Room得到了很好的保护，默认情况下，你不能进行任何调用——如果你敢这样做，就会抛出一个异常，导致崩溃。这就是RxJava派上用场的地方，因为它允许轻松地将所有工作委托给另一个线程，这也是我将在第2部分中介绍的方法。当然，选择权在你，你可以使用你所知道的任何其他解决方案。</p>
<p>另一件Room不会阻止你做的事情是编写SQL查询，但由于内置的注释和编译时检查，它们会少得多，而且会更友好。这将让您毫无争议地体验SQLite的全部功能。</p>
<h2><span>还有更多</span></h2>
<p><span>我们介绍了Room的基本功能及其与翻新的相似之处，但这并不是全部。在第2部分中，我们将深入探讨实现细节，一些问题和我们在实现示例应用程序时发现的Room的酷功能(将与本文的第2部分<a href="/web/20220925022810/https://www.netguru.com/blog/check-out-why-room-is-a-retrofit-for-sqlite-pt.-2" rel="noopener">一起发布</a>)。</span></p></span></div>    
</body>
</html>