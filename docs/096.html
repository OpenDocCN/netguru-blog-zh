<html>
<head>
<title>WebSockets on Android Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Android上的WebSockets变得简单</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/websockets-on-android-made-easy#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/websockets-on-android-made-easy#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h2"><p>在我们的内部项目中使用WebSockets一段时间后，我想与你分享我的想法和经验。</p></div><h2>有什么问题？</h2>
<p>在我们的应用中，我们需要一种设备间本地通信的解决方案。在寻找解决方案时，我们不得不考虑其中一台设备需要作为服务器使用。经过快速研究，我们发现最佳选择是Java WebSockets库。主要优势是它能够在android设备上同时处理服务器和客户端。这些功能的主要实现需要扩展两个类: <em> WebSocketClient </em> <span>和</span> <span> <em> WebSocketServer </em>、</span> <span>并覆盖它们的函数。剩下的逻辑来自正确的消息处理。</span></p>
<h2><span> WebSocket服务器</span></h2>
<p>为了实现sockets服务器，我们需要实现基本的钩子函数。</p>
<pre><code class="language-java">import org.java_websocket.WebSocket
import org.java_websocket.handshake.ClientHandshake
import org.java_websocket.server.WebSocketServer
import java.net.InetSocketAddress

class CustomWebSocketServer(
   port: Int? = null
) : WebSocketServer(InetSocketAddress(port ?: PORT)) {

   override fun onOpen(conn: WebSocket?, handshake: ClientHandshake?) = Unit
   
   override fun onClose(conn: WebSocket?, code: Int, reason: String?, remote: Boolean) = Unit

   override fun onMessage(conn: WebSocket?, message: String?) = Unit

   override fun onMessage(conn: WebSocket?, message: ByteBuffer?) = Unit

   override fun onStart() = Unit

   override fun onError(conn: WebSocket?, ex: Exception?) = Unit

   companion object {
      internal const val PORT = 50123
   }
}
</code></pre>
<p>因为我们正在处理一个跨平台的应用程序，我们还需要覆盖onMessage(conn: WebSocket？，消息:ByteBuffer？) <span>因为iOS是以字节为单位发送消息的。这就是我们也以字节形式发送消息的原因。如果我们需要保持设备连接到我们的服务器，每一个设备都要经过</span> <span> onOpen </span> <span>，只需保持对</span><span>conn:web socket</span><span>的引用。我们的项目规范要求我们的服务器同时与所有客户端通信，因此我们不需要特定的引用。服务器能够发送广播，所以它会派上用场。</span></p>
<br/>
<p>在我们开始实现消息处理之前，请记住，如果您想继续重用同一个端口，您应该添加</p>
<pre><code class="language-java">isReuseAddr = true</code></pre>
<p>在您的init块中。如果您不添加它，您要么必须在每次启动时更改您的端口，要么您的服务器有时会在同一个端口上启动时出现问题。</p>
<p>要启动服务器，你必须调用 <span> start() </span> <span>方法。这个方法会阻塞主线程。在我们的项目中，我们使用RxJava在后台执行它。</span></p>
<p>说到消息传递，正如我前面提到的，为了支持iOS，我们还需要覆盖second onMessage函数:</p>
<pre><code class="language-java">override fun onMessage(conn: WebSocket?, message: ByteBuffer?) {
   message ?: return
   val buffer = ByteArray(message.remaining())
   message.get(buffer)
   onMessage(conn, String(buffer, Charset.defaultCharset()))
}
</code></pre>
<br/>
<p>现在，我们也能够接收来自iOS的消息，我们可以实际与消息进行交互。那么，让我们在构造函数中添加一个高阶函数:</p>
<pre><code class="language-java">class CustomWebSocketServer(
   port: Int? = null,
   private val onMessageReceived: (WebSocket?, String?) -&gt; Unit
) : WebSocketServer(InetSocketAddress(port ?: PORT)) {
…
   override fun onMessage(conn: WebSocket?, message: String?) {
      onMessageReceived(conn, message)
   }
…
}
</code></pre>
<p>我们马上就会回到我们的服务器。是时候和客户一起做些工作了。</p>
<h2>WebSocket客户端</h2>
<pre><code class="language-java">import org.java_websocket.client.WebSocketClient
import org.java_websocket.handshake.ServerHandshake
import java.net.URI

class CustomWebSocketClient(
   val address: String
) : WebSocketClient(URI(address)) {
    
   override fun onOpen(handshakedata: ServerHandshake?)  = Unit

   override fun onClose(code: Int, reason: String?, remote: Boolean)  = Unit

   override fun onMessage(message: String?)  = Unit

   override fun onError(ex: Exception?)  = Unit
}</code></pre>
<p><span>正如你在服务器超级构造器上看到的，我们需要做的就是用给定的端口传递</span><span>InetSocketAddress</span><span>在客户端我们必须用给定的模式</span><span>" ws://$ { ServerIP }:$ { WebSocketPort } "</span><span>传递</span> <span> URI </span> <span>。从这里你所要做的就是从后台线程调用</span> <span> connect() </span> <span>，因为就像服务器一样，它会阻塞主线程。我们需要覆盖onMessage(bytes: ByteBuffer？)从iOS服务器接收信息。</span></p>
<pre><code class="language-java">class CustomWebSocketClient(
   address: String,
   private val onMessageReceived: (String?) -&gt; Unit
) : WebSocketClient(URI(address)) {
…
   override fun onMessage(message: String?) {
      onMessageReceived(message)
   }

   override fun onMessage(bytes: ByteBuffer?) {
      bytes ?: return
      val buffer = ByteArray(bytes.remaining())
      bytes.get(buffer)
      onMessage(String(buffer, Charset.defaultCharset()))
   }
…
}
</code></pre>
<br/>
<p>现在我们已经实现了客户端和服务器，终于到了发送一些消息的时候了。</p>
<h2>信息发送</h2>
<p>我们决定使用JSON格式处理消息。为了构造和管理我们的消息，我们可以使用org.json包中的JSONObject类型。</p>
<br/>
<p>如果我们想要从我们的服务器广播特定的操作来通知所有连接的客户端，我们所要做的就是创建一个简单的消息并如下发送它:</p>
<pre><code class="language-java">val jsonObject = JSONObject().apply {
   put("notify", "remember to eat your vegetables")
}

server?.broadcast(jsonObject.toString().toByteArray(Charset.defaultCharset()))
</code></pre>
<p>在客户端，我们现在可以显示收到的通知:</p>
<pre><code class="language-java">CustomWebSocketClient(
   address =  "ws://192.160.0.98:50123",
   onMessageReceived = { message -&gt;
      val jsonObject = JSONObject(message)
      if (jsonObject.has("notify")) {
         showSnackbar(jsonObject.getString("notify"))
      }
   }
)
</code></pre>
<p>这就是实现简单的基于套接字的服务器-客户端通信所需的全部内容。现在，您可以使用一些额外的功能来扩展您的实现，比如通知连接性的变化或添加客户端-服务器消息传递。</p>
<br/>
<p>作为专业建议，我想提一下Java WebSockets最大的缺点是，当你的服务器崩溃时，你需要创建一个新的实例。幸运的是，在客户端，您可以只调用 <span> reconnect() </span></p>
<h2>最终世界</h2>
<p>当您的应用程序需要维护客户端应用程序和服务器之间的持久连接时，WebSockets就派上了用场。至于我们的需求，我们设法处理音乐播放中的变化，以及简单地通知客户端应用程序某些事件。如果您对构建客户端-服务器应用程序感兴趣，请告诉我们。我们很乐意帮忙。</p>
<hr/>
<p><span>照片由<span> </span> </span> rawpixel <span> <span> </span>上<span> </span> </span> <a href="http://web.archive.org/web/20221201143122/https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">下</a></p></span></div>    
</body>
</html>