# 案例研究:如何在 Web 应用程序中使用 SOA

> 原文：<http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/soa-web-apps-tips>

 假设你是一名零售商，想要编写一个 web 应用程序来列出你的产品(书籍、DVD、CD 等)。)在大型电商平台上以尽可能好的价格。然而，竞争是激烈的，他们通常会为同样的产品设定仅比你低几分的价格，这样他们的产品就会出现在搜索结果页面的顶部。你是如何应对的？

## SOA Web 应用的要素

让我们想想你到底需要什么:

*   你想卖的产品清单，
*   关于这些产品的详细信息，
*   你想卖这些产品的最低价格，
*   包装尺寸、重量、状况，
*   每种产品的最新竞争信息，
*   你的报价数据库。

你的应用程序应该如何为你想要销售的每件产品工作的粗略描述可能是:

*   收集关于当前现有报价的信息，
*   找到最便宜的报价，
*   将它降低一个指定的量(比如 0.01 美元)，
*   检查新价格是否不低于指定的阈值，
*   将价格更新推送到电商平台。

太棒了。让我们来构建应用程序吧！

### 将应用分成更小的部分

这项任务将需要几个数据库和一些工人做自己独特的工作。总的来说，听起来会有很多后台工作和数据库工作。首先要做的不是构建整个应用程序，而是将应用程序分成小的、特定的部分，与面向服务的架构模式保持一致。

SOA 模式的主要优势是:

*   小应用程序大小，
*   易于测试，
*   独立于其他应用程序，
*   一个简单的工作流程:做好你的工作，将结果发送给某个消息代理(如 *redis* 或 *RabbitMQ* )，不要担心其他的事情！

这种划分会是这样的:

1.  **产品**
    1.  存储您想要销售的产品的信息
    2.  使用 API 平台收集产品信息(尺寸、描述、图片)
    3.  公开一个简单的 API，返回特定产品的完整信息
2.  **比赛**
    1.  收集我们想要销售的每种产品的竞争报价信息
    2.  检测竞争对手的价格变化，并将该信息发送给**消息代理**
    3.  公开一个简单的 API，返回有关竞争报价的信息
3.  **创建者**
    1.  将我们的报价存储在数据库中
    2.  监听**消息代理**从**竞争**应用传入的变化
    3.  使用来自**产品**和**竞争**应用程序的信息(使用其公开的 API)找到最佳报价并适当重新定价
    4.  检测我们报价的变化，并将此信息发送到**消息代理**应用
4.  **推动器**
    1.  在**创建者**中监听**消息代理**传入的变更
    2.  向电子商务平台推送价格更新

有了这样的结构，我们就可以将具体的工作分配给不同的应用程序，并专注于开发或改进其中的一个应用程序，而不是将一个应用程序作为一个整体来考虑。

### 对 API 调用使用缓存

这听起来可能有点显而易见，但它经常被遗忘。如果您的目标是每分钟达到 API 45k 次，那么在某些情况下，只需缓存响应就可以了。它节省了数据库读取和 Ruby 代码的执行，以便生成 json 响应——仅举几例。

第一个想到缓存的软件是 **memcache** 。但是，我会推荐使用**redis**——redis 在缓存性能方面胜过 memcache。

### 使用 Redis 发布/订阅，并使用队列在应用程序之间发送信息

竞争应用程序在检测到竞争报价的变化后，会将这些信息发送给创造者应用程序，并修改我们的价格。有几种方法可以做到这一点:

1.  打电话给**创建者** API 询问变更情况
2.  在**创建者的**后台工作器中添加一个后台工作
3.  将信息直接放入**创建者**数据库

不幸的是，这些解决方案都不能奏效。为什么？

1.  调用 **creator** 是这三个中最好的选择，但还是不完美。它要求**竞赛**应用程序引用**创造者**应用程序，违反了 SOA 规则。此外，如果另一个应用程序也想知道这些变化呢？我们必须重构代码来添加另一个 API 调用。
2.  与前一个问题类似，我们需要引用**创建者**应用程序中的工人。改变那个工人也需要我们参考**竞赛**应用中的改变。
3.  将数据库暴露给其他服务器、添加特权或不跟踪数据库模式只是这个建议的几个问题。这是最糟糕的主意。

所有这些问题都可以通过使用 redis **发布/订阅**方法来解决。简而言之:**竞赛**应用程序将信息推送到一个特定的 redis 频道，另一个应用程序监听该频道以获取信息。这个解决方案非常适合 SOA 架构。**竞赛**应用程序只是向全球频道发送信息，并不关心它发生了什么。这也允许我们让多个应用程序监听同一个通道，并相应地执行它们的工作。

使用 redis 发布/订阅系统非常简单。从命令行执行该操作如下所示:

打开终端并执行

您应该会看到类似这样的内容

现在，打开另一个终端并执行

您应该在第一个终端中看到类似这样的内容

这意味着 redis 已经在“信道”上收到消息“一条消息”。通过这种方式，您可以向一个频道发送任何消息，其他的**订户**将获取该消息。

在 Ruby 中做到这一点非常简单。侦听器工作器可能看起来像这样:

发布代码非常简单:

我推荐使用这种方法，因为它可以让你轻松地将更多的应用程序连接到同一个频道，而无需重构。

对服务器上的 Raid 使用正确的索引和 SSD 驱动器

### 数据库需要一个良好的基础来存储大量的数据并快速访问这些数据。了解索引是如何工作的，并将它们添加到阅读量最大的列中，这一点很重要。

拥有太多的索引是不好的，因为每次你改变数据库中的一些东西(添加记录、修改、删除等等)。)，索引树将不得不被重写。索引太少会导致检索数据时出现问题。没有解决这类问题的好方法——每个表都是不同的，您应该根据自己的需要来设计数据库结构。

然而，在您的机器上使用 SSD 驱动器肯定会有助于加快您的数据库。像快盘和固态硬盘这样的数据库速度很快。；)

对所有长期运行的任务使用后台作业

### 我谈到了使用 redis subscribe 方法从其他应用程序获取数据。为什么不在收到消息后立即执行必要的作业呢？因为执行它需要时间，因此会阻塞任何其他传入的消息。对于侦听器任务来说，最好只将消息放入一个队列(sidekiq 或类似的队列),让后台作业工人从队列中取出消息，然后执行它。

您可能会想“嘿，但是我可以运行多个侦听器，并以与后台工作人员相同的方式执行作业！”-这并不完全正确。如果您运行 5 个侦听器工作器，那么所有这些工作器都将从 redis 通道收到一条消息，并且它们都将执行相同的任务。那大概不是你想要达到的吧？

这些技巧应该可以帮助你开始构建易于扩展的大型高性能应用程序。希望你觉得有用！

如果你想了解更多关于 Ruby on Rails 的信息，请查看我们的[顶级 RoR 播客列表](/web/20220925202635/https://www.netguru.com/blog/top-7-ruby-on-rails-podcasts) ！

*P.S. If you want to learn more about Ruby on Rails, check out our [list of top RoR podcasts](/web/20220925202635/https://www.netguru.com/blog/top-7-ruby-on-rails-podcasts)*!