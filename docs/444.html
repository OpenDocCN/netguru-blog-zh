<html>
<head>
<title>How To Setup Your Rails Backend For Pusher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何为Pusher设置Rails后端</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/how-to-setup-your-rails-backend-for-pusher#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/how-to-setup-your-rails-backend-for-pusher#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h2"><p id="id-[#ng-training]SetupyourRailsbackendforPusher-UsingPusher.js-readytouseSaaSprovidingwebsocketsinmultipletechnologies">Pusher.js准备使用SaaS提供多种技术的websockets。无论有无授权，它都可以处理公共、私人和客户事件。</p></div><p>您将使用的内容:</p>
<p><a href="http://web.archive.org/web/20221202084845/https://github.com/pusher/pusher-http-ruby" rel="nofollow"> pusher gem </a> -作为服务器gem，负责向客户端触发事件(事件也可以在除服务器之外的客户端之间触发，但它需要更多的配置，这将在后面解决)。</p>
<h3 id="id-[#ng-training]SetupyourRailsbackendforPusher-Whatyouwilluse:">优点:</h3>
<ul>
<li>易于设置，</li>
</ul>
<h3>提供的支持，</h3>
<ul>
<li>适用于Ruby、iOS、Android和JavaScript。</li>
<li>客户名称:</li>
<li>步骤1:设置初始化</li>
</ul>
<h3>Pusher将作为一个全局单例对象在初始化器中设置。您需要将pusher.rb添加到您的初始化器中，这将简单地定义应用凭证并启用加密。</h3>

<br id="id-[#ng-training]SetupyourRailsbackendforPusher-Whatyouwilluse:"/>
<h3 id="id-[#ng-training]SetupyourRailsbackendforPusher-Setupinitializer">步骤2:创建Pusher::Dispatcher服务来触发事件</h3>
<p>这一步取决于您选择的架构。我选择使用<span> Pusher::Dispatcher </span>类来触发Pusher singleton。看起来有点过了，但是这是一个基于一些变量(例如用户id)计算频道名称的好地方。</p>
<h3 id="id-[#ng-training]SetupyourRailsbackendforPusher-CreatePusher::Dispatcherservicetotriggerevents">请注意，通道可以按照您喜欢的方式命名——它是由Pusher按需创建和处理的，不需要提前定义。你只通过服务器在频道上发送事件，每个连接到你的频道的人都会收到这些特定的事件。</h3>
<p> </p>
<p>步骤3:添加授权端点</p>
<p>推动器中的授权非常简单:</p>
<h3 id="id-[#ng-training]SetupyourRailsbackendforPusher-Addauthorizationendpoint">您为每个客户端提供一个授权端点(例如在前端或iOS应用程序上)，</h3>
<p>当客户端想要连接时，它使用客户端定义的参数访问端点，</p>
<ul>
<li>您的端点应验证这些参数(例如，检查授权令牌)，并使用您选择的参数通过Pusher singleton对象验证连接，例如，将在连接到此通道的其他客户端之间共享的关于当前授权用户的更多数据。</li>
<li>每个客户端可以在初始化期间定义其授权端点，例如在前端应用程序或iOS应用程序中，您可以使用指向<span>https://myapp.com/api/pusher/auth</span>的授权端点来初始化推送器。</li>
<li>客户端还可以配置它们发送到该端点的参数，例如，您可以向您的<span> /api/pusher/auth </span>端点发送前端应用程序中使用的当前用户ID和auth令牌。</li>
</ul>
<p>让我们称我们的端点为<span> /api/pusher/auth </span>。有一个操作需要实现。</p>
<p>安全、简单、可靠。</p>
<p>步骤4:调试和验证</p>
<p>您可以轻松地调试和验证您的Pusher实现，根本不需要任何前端。在我的应用程序中，基本上没有业务逻辑，我创建了一个简单的端点，它将根据测试需求触发Pusher事件。</p>
<p>现在，我可以使用CURL简单地触发Pusher事件:</p>
<h3 id="id-[#ng-training]SetupyourRailsbackendforPusher-Debugandvalidate">Pusher的酷之处在于它在网上提供了优秀的调试控制台。这意味着你不需要一个前端就绪的解决方案——在后端工作直到你准备好！</h3>
<p>转到Pusher仪表板中的调试控制台，重启服务器，观察Pusher是否正在获取所需的数据！</p>
<p>摘要</p>
<div title="Hint: double-click to select code">
<pre>curl http://localhost:3000/api/pusher/trigger?channel_name=test&amp;event=myEvent</pre>
</div>
<p>你已经设置好所有你需要的东西，完全接受推杆底座的可能性。您可以处理公共频道、私人频道和在线频道(私人频道和在线频道需要授权)。这些事件可以很容易地被触发，并且您有一个可重用的<span> Pusher::Dispatcher </span>类。您刚刚学习了Pusher调试控制台，这是您工具箱中的必备组件。干得好！</p>
<p>Go to your Debug Console in the Pusher dashboard, restart your server and observe if Pusher is getting the needed data!</p>
<p> </p>
<h3>Summary</h3>
<p>You have set up all you need to embrace Pusher base possibilities <span>fully</span>. You can handle public, private and presence channel (private and presence demands authorisation). The events can be triggered easily, and you have a reusable <span>Pusher::Dispatcher</span> class. You've just learned about Pusher Debug console, which is a must-have in your toolbelt. Good job!</p></span></div>    
</body>
</html>