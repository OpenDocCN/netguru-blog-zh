<html>
<head>
<title>End to End Tests on CircleCI with Docker - Rails, Capybara, Selenium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Docker - Rails、Capybara和Selenium对CircleCI进行端到端测试</h1>
<blockquote>原文：<a href="http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/end-to-end-tests-on-circleci-with-docker-rails-capybara-selenium#0001-01-01">http://web.archive.org/web/20230307163032/https://www.netguru.com/blog/end-to-end-tests-on-circleci-with-docker-rails-capybara-selenium#0001-01-01</a></blockquote><div><span><div class="blog-post__lead h3"><p>web开发世界变化很快。我觉得我们正通过将后端部分提取到一个API中来将整体web应用程序一分为二。尽管这个解决方案有很多优点，但它也带来了一些困难。其中之一是端到端测试。</p></div><p>以适当的方式执行这些测试可能真的很棘手，尤其是当我们对外部主机上的过程没有太多控制时，例如在CircleCI构建期间。</p>
<p>我决定与你分享我所学到的——如何在CircleCI上设置端到端测试。下面的说明可以很容易地应用于除Rails和React之外的任何框架组合。然而，当前形式的文章是这样引用配置的:</p>
<ul>
<li>
<p>两个独立的后端(Rails)和前端(React——类型并不重要)应用在独立的repos上</p>
</li>
<li>
<p>Rails中的测试由RSpec使用Capybara + Selenium + ChromeDriver执行</p>
</li>
<li>
<p>CircleCI配置假定包含Docker和docker-compose</p>
</li>
<li>
<p>使用当前CircleCI设置和用于筹备和生产的文档化应用程序，在现有项目上执行设置流程</p>
</li>
</ul>
<p>我想写一篇简单的文章，但我会尽可能多地涵盖在设置过程中可能出现的“如果”、“等等，会是什么”等问题。showed文件中的大多数行对于这个设置来说都是必不可少的，并给出了注释和解释。这里的大图是允许在后端编写集成测试(位于规范/特性中)，在没有Docker的情况下在本地测试它们，并在CircleCI上的前端应用构建期间运行。</p>
<h2><strong>本地测试-后端</strong></h2>
<h3><strong>环境设置</strong></h3>
<p>确保给<code>Gemfile</code>添加合适的宝石:</p>
<pre><code class="language-ruby">...
group :test do
	...
	gem "capybara", "~&gt; 2.7", "&gt;= 2.7.1"
	gem "chromedriver-helper", "~&gt; 1.0"
	gem "rspec_junit_formatter"  # Preparing proper output for CircleCI test metadata
	gem "selenium-webdriver", "~&gt; 2.53", "&gt;= 2.53.4"
end
</code></pre>
<p>然后在<code>bundle install</code>之后，让我们在两个文件中添加水豚和Selenium的配置:</p>
<pre><code class="language-ruby">require "capybara/rails"
require "selenium-webdriver"

...

Capybara.register_driver :chrome do |app|
  Capybara::Selenium::Driver.new(
    app,
    browser: :chrome,
    desired_capabilities: { "chromeOptions" =&gt; { "args" =&gt; %w[window-size=1024,768] } },
  )
end

Capybara.register_driver :selenium do |app|
  Capybara::Selenium::Driver.new(app, browser: :chrome)
end

Capybara.configure do |config|
  config.default_max_wait_time = 10
  config.default_driver        = :selenium
end

Capybara.app_host = "http://localhost:3000"
Capybara.javascript_driver = :chrome
Capybara.server_port = 5001 # We don't want it to collide with standard rails server on port 5000
Capybara.server_host = "0.0.0.0" # Start server on localhost as meta-address
Capybara.server = :puma, { Silent: true } # Supress puma STDOUT in console

...
</code></pre>
<pre><code class="language-ruby">require "capybara/rspec"
</code></pre>
<p>因为我们的测试将放在:<code>spec/features</code>circle ci上的测试套件将会失败。我们不想在后端的CircleCI上配置e2e测试。这就是为什么我们需要在<code>circle.yml</code>中覆盖测试命令:</p>
<pre><code class="language-ruby">machine:
  services:
    - redis
  environment:
    ES_JAVA_OPTS: "-Xms2g -Xmx2g"
    _JAVA_OPTIONS: "-Xms1024m -Xmx2048m"
    CONTINUOUS_INTEGRATION: true
dependencies:
  post:
    - if [[ ! -e elasticsearch-5.5.1 ]]; then wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.tar.gz &amp;&amp; tar -xvf elasticsearch-5.5.1.tar.gz; fi
    - elasticsearch-5.5.1/bin/elasticsearch: { background: true }
test:
  post:
    - bundle exec codeclimate-test-reporter
    - bundle exec bundle-audit check --update
    - bundle exec brakeman -f plain
  override:                                                              # ADD this section
    - bundle exec rspec --exclude-pattern "spec/features/**/*.rb"        # We override Circle's test command here to explicitly exclude features specs
deployment:
  master:
    branch: master
    commands:
      - cd deployment; bundle install; bundle exec cap staging deploy
</code></pre>
<h2><strong>本地测试-前端</strong></h2>
<h3><strong>环境设置</strong></h3>
<p>这个很简单——几乎不需要任何设置。</p>
<p>您唯一要做的事情就是将请求指向特定的后端地址(在我们的例子中是<code>rails_spec.rb</code>中所述的<code>http://localhost:5001</code>)。这是因为我们希望前端应用程序在测试期间使用与rspec相同的数据库——只有在这种情况下测试才是可行的。</p>
<p>这一步取决于您在项目中使用的技术。可以肯定地说，大多数javascript项目都有<code>package.json</code>文件。通常我们通过命令启动本地服务器:</p>
<p><code>$ yarn start</code></p>
<p>既然我们不想搞乱开发环境，我们可以在<code>package.json</code>中添加自定义的<code>start-test</code>命令:</p>
<pre><code class="language-ruby">"scripts": {
    "build": "react-scripts build",
    ...
    "start": "react-scripts start",
    "start-test": "REACT_APP_API_BASE_URL=http://localhost:5001 react-scripts start",
    ...
</code></pre>
<p>我们的前端应用程序依赖于env变量<code>REACT_APP_API_BASE_URL</code>,该变量用于构建到rails API的引用链接。有了以上内容，我们现在可以使用:</p>
<p><code>$ yarn start-test</code></p>
<p>在你的项目中，你必须弄清楚如何设置它。可能性:</p>
<ul>
<li>
<p>应用程序在某个时候使用的任何其他env变量——设置服务器启动的适当环境。:<code>APP_ENV=test</code>或<code>NODE_ENV=test</code></p>
</li>
<li>
<p>设置。环境变量同上的env文件</p>
</li>
<li>
<p>API相关服务/组件中的某种<code>if clause</code></p>
</li>
</ul>
<h2><strong>是活的吗？</strong></h2>
<p>如果您已经正确地设置了所有的东西，那么您就可以在本地运行e2e测试了。简单的<code>is it working?</code>测试用例:</p>
<pre><code class="language-ruby">require 'rails_helper'

feature 'Home page', js: true do
  scenario 'visit home page' do
    visit '/'
    expect(current_path).to eq '/'
    expect(page.first('span').text).to eq("About Us")
  end
end...
</code></pre>
<p>在我们启动前端的本地服务器后，如前一节所述，我们将通过以下方式手动运行规范:</p>
<p><code>$ rspec spec/features</code></p>
<p>现在让我们转到<strong> Crème de la crème </strong> - CircleCI设置！</p>
<h2><strong> CircleCI -先决条件</strong></h2>
<p>让我们从确定您将处理的文件开始:</p>
<p><code>Dockerfile</code>-docker使用的文件，包含docker构建特定容器所需的所有信息和命令(容器就像一个小环境，有自己的依赖项、变量和配置)。现在看看你的文档。它没有任何扩展。<strong>重要</strong>检查你当前的<code>Dockerfile</code>是否有两个(或更多)<code>FROM</code>指令。如果是，那么这是一个CircleCI方面的问题。看，这被称为多阶段构建，这很棒(它使用一个图像，从它获取一些东西，从另一个图像添加一些东西，并构建一个图像，从这个图像你可以设置你的容器。在单阶段中，你必须从头开始构建单独的图像——它们会占用更多的空间和时间)，但CircleCI不是这样。多阶段构建需要Docker v17.05及以上版本(Circle 1.0上的标准Docker要老很多)。我们可以强制使用那个版本，但是只能在CircleCI v2.0上。所以基本上，如果你有CircleCI v1.0和多阶段构建docker file——你就有一个问题要解决。<a href="http://web.archive.org/web/20220924170825/https://docs.docker.com/engine/reference/builder/" rel="nofollow"> Dockerfile参考</a></p>
<p>如果你有这样命名的文件，那么你可以使用CircleCi v1.0。这个版本更容易设置。对于v2.0，有一个<code>.circleci/config.yml</code>文件，它的结构是不同的。如果你愿意，你可以按照下面的步骤从1.0迁移到2.0:<a href="http://web.archive.org/web/20220924170825/https://circleci.com/docs/2.0/migrating-from-1-2/" rel="nofollow">从1迁移到2 </a>但是我个人不推荐，除非你真的知道你在做什么。然而，使用2.0有很多优点——新版本的<code>Docker</code>和<code>docker-compose</code>支持像<code>exec</code>这样有用的命令。<a href="http://web.archive.org/web/20220924170825/https://circleci.com/docs/1.0/configuration/" rel="nofollow"> Circle.yml参考</a></p>
<p><code>docker-compose.yml</code> -由<code>docker-compose</code>工具使用的文件。您可以将该文件视为一个容器列表(通过引用Dockerfile或Docker Hub中的图像来指定),这些容器具有各自的配置。这是最重要的文件，你必须在其中放置你需要的安装程序的每个部分:rails，front，postgres，redis等等。<a href="http://web.archive.org/web/20220924170825/https://docs.docker.com/compose/compose-file/" rel="nofollow"> Docker-compose.yml参考</a>。</p>
<h2><strong> CircleCI - Backend </strong></h2>
<h3><strong>设置环境</strong></h3>
<p>在我看来，这里最好的方法是为rails应用程序添加特定的环境，专门为CircleCI上的端到端测试定制。我选的名字:<code>e2e</code>。这很方便，实际上可以是任何名字。首先:</p>
<ul>
<li>
<p>将<code>config/environments/test.rb</code>复制为<code>config/environments/e2e.rb</code></p>
</li>
<li>
<p>在<code>Gemfile</code>中，将<code>:e2e</code>添加到为<code>:test</code>指定的每个组，以及组定义中。</p>
</li>
<li>
<p>如果您有秘密，那么您应该在<code>config/secrets.yml</code>中为<code>e2e</code>创建一个名称空间(从开发中复制定义)，并在加密密钥中添加适当的<code>secret_key_base</code>(在我们的项目中，我们通过<code>EDITOR=nano rails secrets:edit</code>编辑秘密)</p>
</li>
<li>
<p>请记住，在使用<code>Rails.env.test?</code>或类似设置/检查的地方，您可能也想指定在<code>e2e</code>环境下如何操作</p>
</li>
<li>
<p>如果您使用任何类型的请求模仿/抑制/模仿(如<a href="http://web.archive.org/web/20220924170825/https://github.com/bblimke/webmock" rel="nofollow"> webmock </a>或<a href="http://web.archive.org/web/20220924170825/https://github.com/vcr/vcr" rel="nofollow"> vcr </a>)，您将需要将虚拟网络中的容器名称列入白名单，例如<code>frontend</code>、<code>elasticsearch</code>、<code>postgres</code>、<code>redis</code>等。</p>
</li>
</ul>
<p>创建新文件<code>config/database.e2e.yml</code>:</p>
<pre><code class="language-ruby">e2e:
  adapter:  postgresql
  host:     postgres
  encoding: unicode
  database: your_project_test
  pool:     5
  username: postgres
  password: your_password
</code></pre>
<p>创建<code>Dockerfile.e2e</code>(或者复制项目中的其他<code>Dockerfile</code>)。我们被安置在<code>docker/Dockerfile.e2e</code>。你的<code>Dockerfile</code>可能看起来像下面这个。您也可以使用<a href="http://web.archive.org/web/20220924170825/https://docs.docker.com/engine/reference/builder/" rel="nofollow noopener"> Dockerfile reference </a>从头创建一个。</p>
<pre><code class="language-ruby">FROM quay.io/netguru/baseimage:0.10.1                                 # Image containing all dependecies like imagemagick etc

ENV RUBY_VERSION 2.4.2                                                # To get proper ruby

## Install Ruby &amp; Dependencies
RUN \                                                                 # Install ruby
  apt-get update -q &amp;&amp; \
  apt-get install -q libcurl3 &amp;&amp; \
  apt-get install -q -y cron &amp;&amp; \
  ruby-install --system --cleanup ruby $RUBY_VERSION -- --disable-install-rdoc &amp;&amp; \
  gem install bundler

## Copy Gemfile &amp; bundle
ADD Gemfile* $APP_HOME/                                               # Gemfile installation
RUN bundle install --jobs=8 --retry=3

## Add rest of code
ADD . $APP_HOME/                                                      # Copy to APP_HOME folder

ENV RAILS_ENV e2e                                                     # Set env to e2e
ENV WEB_CONCURRENCY 2                                                 # Puma concurrency
ENV AVAILABLE_MEMORY 1200                                             # How much memory the container can use
ENV RAILS_SERVE_STATIC_FILES true                                     # Serve static assets
ENV REDIS_URL redis://redis:6379/0                                    # Set Redis url and port

ADD ./config/database.e2e.yml /app/config/database.yml                # Copy database config
RUN mkdir /app/rspec_output                                           # Create directory for rspec results

RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*    # Cleaning up

# Elasticsearch
ENV ELASTICSEARCH_URL=http://elasticsearch:9200                       # Our case - setup ElasticSearch url and port

EXPOSE 5001                                                           # Container will listen on this port

</code></pre>
<p>在本地将e2e特定的配置添加到<code>rails_helper.rb </code>，ENV是‘测试’，而在CircleCI上是‘e2e’。我们不想自动启动测试服务器。它将以不同的方式启动:</p>
<pre><code class="language-ruby">Capybara.register_driver :chrome do |app|
  Capybara::Selenium::Driver.new(
    app,
    browser: :chrome,
    desired_capabilities: { "chromeOptions" =&gt; { "args" =&gt; %w[window-size=1024,768] } },
  )
end

if Rails.env.test?
  Capybara.register_driver :selenium do |app|
    Capybara::Selenium::Driver.new(app, browser: :chrome)
  end

  Capybara.configure do |config|
    config.default_max_wait_time = 10
    config.default_driver        = :selenium
  end

  Capybara.app_host = "http://localhost:3000"
  Capybara.javascript_driver = :chrome
  Capybara.server_port = 5001
  Capybara.server_host = "0.0.0.0"
  Capybara.server = :puma, { Silent: true }
else
  args = ["--no-default-browser-check", "--start-maximized"]
  caps = Selenium::WebDriver::Remote::Capabilities.chrome("chromeOptions" =&gt; { "args" =&gt; args })
  Capybara.register_driver :selenium do |app|
    Capybara::Selenium::Driver.new(
      app,
      browser: :remote,
      url: "http://selenium:4444/wd/hub",
      desired_capabilities: caps,
    )
  end

  Capybara.configure do |config|
    config.default_max_wait_time = 15
    config.default_driver        = :selenium
  end

  Capybara.app_host = "http://frontend:3000"    # Containers communicate by aliases, hence 'frontend'
  Capybara.javascript_driver = :selenium
  Capybara.run_server = false                   # To ensure everything is in sync don't start puma automatically
end                                             

</code></pre>
<p>将启动specs所需的所有命令放在一个脚本中是一个非常好的主意。我们可以在<code>docker/e2e.sh</code>中创建一个。这个bash脚本将由一个<code>docker-compose</code>在容器中启动。</p>
<pre><code class="language-ruby">#!/bin/bash

echo "Setting up and running e2e tests!"

# Create database and seed (since we might want to include some data needed for our app to work properly like oauth clients
rails db:setup

# Start puma server in e2e environment on meta-address host on port 5001 in detached mode
RAILS_ENV=e2e puma -b tcp://0.0.0.0:5001 -d

# Start feature specs and output results to xml file
rspec --format progress --format RspecJunitFormatter --out ./rspec_output/rspec.xml spec/features
</code></pre>
<p>就是这样！我们完成了后端。</p>
<h2><strong> CircleCI -前端</strong></h2>
<h3><strong>设置环境</strong></h3>
<p>在项目的主目录中创建新的<code>docker-compose.ci.yml</code>文件，或者复制并重命名当前文件。<code>docker-compose-staging.yml</code>。你需要设置一些东西:后端，卷，端口，别名等适当的依赖关系。一切都在下面解释。最后，该文件应该大致如下所示:</p>
<pre><code class="language-ruby">version: '2'                                       # Version of composer
services:
  backend:                                         # Backend container
    build:
      context: ~/backend                           # Backend should be pulled by git to this location
      dockerfile: docker/Dockerfile.e2e            # The location of Dockerfile, relative to context above
    depends_on:                                    # The containers below will be resolved and loaded before backed
      - redis
      - postgres
      - frontend
      - selenium
      - elasticsearch
    ports:
      - "5001:5001"                                # Expose host_port:container_port
    volumes:
      - "/rspec_output:/app/rspec_output"          # Mount  /rspec_output (on host) to /app/rspec_output (in container)
    environment:
      - RAILS_ENV=e2e                              # This env var will be available to any container instance - used to run rspec in e2e env
      - RAILS_MASTER_KEY                           # If no value is passed this var is going to be read from machine ENV - very useful. Just set RAILS_MASTER_KEY for secrets in CircleCI build config page
    networks:                                      # Virtual network for containers
      main:                                        # Name of the network
        aliases:
          - backend                                # Alias for reference purposes
    command: bash -c "bash /app/docker/e2e.sh"     # Start container by a bash script (container will be alive as long as this script is running)
  frontend:                                        # Frontend container
    build:
      context: .
      dockerfile: Dockerfile.e2e
    command: nginx
    logging:                                       # Disable spamming irrelevant messages from this container
      driver: none
    networks:
      main:
        aliases:
          - frontend                               # Container name in virtual network that can be addressed
    ports:
      - "3000:3000"
    volumes:                                       # Used to mount ./tmp on machine to /app/dist in container
      - "./tmp:/app/dist"
  selenium:                                        # Selenium container
    image: selenium/standalone-chrome
    ports:
      - "4444:4444"
    logging:                                       # Disable spamming irrelevant messages from this container
      driver: none
    networks:
      main:
        aliases:
          - selenium                               # Container name in virtual network that can be addressed
  elasticsearch:                                   # Elasticsearch container (not required) - we used it in project
    image: docker.elastic.co/elasticsearch/elasticsearch:5.5.1
    volumes:
      - "~/es_data:/usr/share/elasticsearch/data"
    environment:
      - "xpack.security.enabled=false"
      - "transport.host=localhost"                 # This line might be needed to disable errors with circleCI 1.0 container memory amount
      - "bootstrap.system_call_filter=false"       # This line might be needed to disable errors with circleCI 1.0 container memory amount
    ports:
      - "9300:9300"
    logging:                                       # Disable spamming irrelevant messages from this container
      driver: none
    networks:
      main:
        aliases:
          - elasticsearch                          # Container name in virtual network that can be addressed
  postgres:                                        # Postgres container
    image: postgres:9.5                            # Postgres version, installed from image on Docker Hub
    environment:
      - POSTGRES_PASSWORD=password                 # There can't be 'blank' password, use one specified in database.e2e.yml
    logging:                                       # Disable spamming irrelevant messages from this container
      driver: none
    networks:
      main:
        aliases:
          - postgres                               # Container name in virtual network that can be addressed
  redis:                                           # Redis container
    image: redis:4.0.6                             # Redis version, installed from image on Docker Hub
    logging:                                       # Disable spamming irrelevant messages from this container
      driver: none
    networks:
      main:
        aliases:
          - redis                                  # Container name in virtual network that can be addressed

networks:                                          # Set virtual network up
  main:

</code></pre>
<p>如果您需要另一个服务(在容器中),只需以类似的方式将其添加到列表中，注意订单。</p>
<p>现在到前端<code>Dockerfile</code>。和以前一样——复制当前的<code>Dockerfile</code>或者在项目的根目录下创建一个。不幸的是，我们有多阶段建造<code>Dockerfile</code>和<code>CircleCI v1.0</code>，所以我不得不把多阶段转换成单阶段。我举个例子。起初我们有这个文件:</p>
<pre><code class="language-ruby">## specify node version
FROM quay.io/netguru/ng-node:6 as builder    # First 'FROM', as builder is used as reference below

## add necessary environments
ENV NODE_ENV staging                         # Set env var

## add code &amp; build app
ADD . $APP_HOME                              # Copy / add external source to image's filesystem
RUN yarn install                             # Install all dependencies for frontend app
RUN yarn build                               # Compile frontend build

## Real app image
FROM nginx:alpine as app                     # Second 'FROM', now it's multi-stage build file

## Copy build/ folder to new image
COPY --from=builder /app/build /app/dist     # Copy file from one image to another by reference - we will have to get rid of it
COPY nginx.conf /etc/nginx/nginx.conf        # Copy nginx config to nginx directory

EXPOSE 3000                                  # Container will listen on this port at runtime
</code></pre>
<p>现在它必须分成两个文件:</p>
<pre><code class="language-ruby">## Real app image
FROM nginx:alpine                       # Remove 'as app'

COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 3000
</code></pre>
<pre><code class="language-ruby">## specify node version
FROM quay.io/netguru/ng-node:6                    # Remove 'as builder'

## add necessary environments
ENV NODE_ENV e2e                                  # Set env
ENV REACT_APP_API_BASE_URL http://backend:5001    # Set env var to point to backend within build. It can be also done by specific command in package.json

## add code &amp; build app
ADD . $APP_HOME
RUN yarn install                                  # Install dependencies
RUN yarn build
</code></pre>
<p>如果你仔细观察，你会发现我删除了<code>COPY --from=builder /app/build /app/dist</code>——这将以不同的方式完成。</p>
<p>上述变化将迫使两个新的步骤。在<code>circle.yml</code>中，我们必须在<code>pyenv rehash</code>后添加<code>dependencies/pre</code>:</p>
<pre><code class="language-ruby">
dependecies:
  pre:
    ...
    - pyenv rehash
    - docker build -t frontend_img -f Dockerfile.e2e.build .    # Builds image from Dockerfile.e2e.build (with our front app)
    - docker create --name frontend_pre frontend_img            # Creates container from image
    - docker cp frontend_pre:/app/build ./tmp                   # Copies /app/build directory (compiled app) from a container to ./tmp in CircleCI machine
    ...
</code></pre>
<p>如果您的配置是:</p>
<ul>
<li><code>multi-stage</code> + <code>v1.0</code> -将多级转换为单级</li>
<li>确保你使用了正确的Docker版本和CircleCI的<code>Edge</code>版本</li>
<li><code>single-stage</code> + <code>v2.0</code> -什么都不做，就用那个<code>Dockerfile</code></li>
<li><code>single-stage</code> + <code>v1.0</code> -什么都不做，就用那个<code>Dockerfile</code></li>
</ul>
<p>最后一步是配置<code>circle.yml</code>，设置命令的优先级，并指示Docker的用法。最后<code>circle.yml</code>应该是这样的:</p>
<pre><code class="language-ruby">machine:
  node:
    version: 8.2.1
  pre:
    - mkdir ~/.cache/yarn
    - curl -sSL https://s3.amazonaws.com/circle-downloads/install-circleci-docker.sh | bash -s -- 1.10.0          # Download Docker 1.10.0 (linked to docker-compose v2) for CircleCI
    - &gt;-
      GIT_SSH_COMMAND='ssh -i ~/.ssh/backend-e2e-tests-deploy-key'
      git clone git@github.com:netguru/project.git ~/backend &amp;&amp; cd ~/backend                   # Download backend to ~/backend. The SSH for backend had to be placed in CircleCI build setup page
    - set -o allexport; source "${HOME}/${CIRCLE_PROJECT_REPONAME}/.env"; set +o allexport
  environment:
    PATH: "${PATH}:${HOME}/${CIRCLE_PROJECT_REPONAME}/node_modules/.bin"
  services:
    - docker                                                    # Enable Docker for this build

dependencies:
  pre:
    - sudo mkdir /rspec_output &amp;&amp; mkdir $CIRCLE_TEST_REPORTS/rspec &amp;&amp; mkdir ~/es_data # make directories for mounting volumes and directory for test metadata. es_data is related to elasticsearch container
    - pip install docker-compose                                # Update docker-compose
    - pyenv rehash                                              # Refresh docker-compose link
    - docker build -t frontend_img -f Dockerfile.e2e.build .    # Build first part of former multi-stage Dockerfile
    - docker create --name frontend_pre frontend_img            # Create container from image above
    - docker cp frontend_pre:/app/build ./tmp                   # Copy compiled frontend app build from container to machine ./tmp dir
    - docker-compose -f docker-compose.ci.yml build             # Build all containers in docker-compose.ci.yml
  cache_directories:
    - ~/.cache/yarn
  override:
    - yarn install

test:
  override:
    - docker-compose -f docker-compose.ci.yml up --exit-code-from backend # Start containers from docker-compose. This will run in foreground and output exit code of bash script
    - ? case $CIRCLE_NODE_INDEX in                                        # Standard frontend tests
        0) yarn test --runInBand ;;
        1) yarn eslint &amp;&amp; yarn stylelint ;; esac
      : parallel: true
    - cp /rspec_output/rspec.xml $CIRCLE_TEST_REPORTS/rspec/rspec.xml     # Copy rspec results to CircleCI test metadata folder

deployment:
  master:
    branch: master
    commands:
      - cd deployment; bundle install; bundle exec cap staging deploy
</code></pre>
<p>就是这样，在这一点上，一切都应该是安全和健全的。如果没有，你的构建就不能让ssh循环运行。</p>
<h2><strong>有用的命令</strong></h2>
<pre><code class="language-ruby">$ docker ps                                         # show running containers
$ docker ps -a                                      # show all containers
$ docker ps -n=-1                                   # show n last created containers
$ docker start                                      # start container
$ docker stop                                       # stop container
$ docker cp :                                       # copy file/directory from container to destinated dir in machine
$ docker cp  :                                      # copy file/directory from machine to container (don't get deceived, read 'understanding volumes' article)
$ docker images                                     # list all images
$ docker rm -f                                      # remove container
$ docker rmi                                        # remove image
$ docker-compose run  <command>                              # run a command in container specified in docker-compose file. Watch out - this command creates new containers each time. Moreover it doesnt create a network!
$ docker-compose exec  <command>                             # execute a command in container that is already running (unavailable in older versions of Docker (CircleCI v1.0))
$ docker-compose up                                 # start containers from docker-compose file by specified commands (creates networks). Containers are running as long as commands which run them
</command></command></code></pre>
<h2><strong>有用的链接</strong></h2>
<p><a href="http://web.archive.org/web/20220924170825/https://docs.docker.com/compose/reference/run/" rel="nofollow">docker-撰写运行参考</a></p>
<p><a href="http://web.archive.org/web/20220924170825/https://docs.docker.com/engine/reference/commandline/cp/" rel="nofollow">码头cp参考</a></p>
<p><a href="http://web.archive.org/web/20220924170825/https://engineering.busbud.com/2017/05/21/going-further-docker-multi-stage-builds/" rel="nofollow">关于多阶段构建的文章</a></p>
<p><a href="http://web.archive.org/web/20220924170825/https://dzone.com/articles/multi-stage-docker-image-build-for-java-apps" rel="nofollow">另一篇关于多阶段构建的文章</a></p>
<p><a href="http://web.archive.org/web/20220924170825/https://docs.docker.com/engine/userguide/eng-image/multistage-build/" rel="nofollow">另一篇关于多阶段构建的文章</a></p>
<p><a href="http://web.archive.org/web/20220924170825/http://container-solutions.com/understanding-volumes-docker/" rel="nofollow">了解容器中的体积</a></p>
<p><a href="http://web.archive.org/web/20220924170825/https://medium.com/@gchudnov/copying-data-between-docker-containers-26890935da3f" rel="nofollow">在容器间复制数据</a></p>
<h2><strong>常见问题解答</strong></h2>
<p>设置很难吗？</p>
<p>可能是吧。一切都取决于你所拥有的CircleCi版本，这限制了与Docker(旧版本)的交互以及你的后端需要多少依赖容器。其中一些可能很难正确设置。</p>
<p>我应该考虑迁移到CircleCI v2.0吗？</p>
<p>肯定！这种构建需要很长时间来执行。有了新版本的Circle，你可能会大大加快速度，并使用新的Docker(更少的错误，一些命令实际上工作，而不仅仅是失败)。</p>
<p><strong>如果我有CircleCI v2.0文件怎么办？</strong></p>
<p>那你应该高兴才对。你在上面看到的一切仍然有效，只是你不必担心多阶段。只需遵循本指南<a href="http://web.archive.org/web/20220924170825/https://circleci.com/blog/multi-stage-docker-builds/" rel="nofollow">使用CircleCI v2.0 </a>构建多级docker，并使用2.0样式<a href="http://web.archive.org/web/20220924170825/https://circleci.com/docs/2.0/" rel="nofollow"> CircleCI v2.0参考</a>重写我们的<code>circle.yml</code>附加行</p>
<h2><strong>总结</strong></h2>
<p>我希望我已经设法描述了一切，使您能够在您的项目中自己设置端到端测试。</p>
<p>如果有什么不清楚的地方，请随时提问。也许文章不清楚或需要改进？也指出来。我相信我们学习的最好方式是通过一个错误，我们都可以从中受益。</p>
<p>后期正打算准备CircleCI v2.0的后续，敬请期待！</p></span></div>    
</body>
</html>